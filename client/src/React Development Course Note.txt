CHAPTER #2: React Key Concepts

---------React Key Concepts---------
- came in 2013
-The Birth of SPA (Single Page Application)
	-> applications acted more like a desktop application where we stay on the same page the entire time and the javascript file simply changes or updates the GMO file or the DOM to display new things.

*****************
REACT CONCEPTS
*****************

---------Declarative vs Imperative---------

	1. Don't touch the DOM. I'll do it
		-pure javascript manipulate the DOM for the entire page (IMPRERATIVE) but React is not. It is DECLARATIVE. It uses Virtual DOM.

		-It takes time to change the DOM. The process is like these:

			1. It repaints
				-change an element and add onto a page and then refloat which is to recalculate the layout of the page and move things around if need to be.

---------Component Architecture---------

	2. Building websites like lego blocks

	-react had this idea of small components that you put them together to form bigger components.

---------One Way Data Flow---------

	3. Unidirectional data flow

		-if the state changed, the data can never move up.

		-this restriction of the data makes it easy to debug code.

---------UI Library---------

	4. UI, the rest is up to you.
		-cross platform
		-imported two libraries in react when starting project:
			1. core react library
			2. React DOM  (Virtual) library


---------How To Be A Great React Developer---------

React Keywords:
	Declarative
	JSX
	State
	Props
	VirtualDOM
	Components

	- we give some state, some components that are built with something called JSX and these components sometimes receive properties which are called Props.

The Job of React Developer:
1. Decide on Components
2. Decide the State and where it lives
3. What changes when state changes.

**********************************************

CHAPTER #3: React Basics

----------Section Overview----------
1. Download Node.js

2. Download NPM and NVM (optional. Used to manage package versions of NPM).

3. Install React commands:
	npm install create-react-app
	create-react-app [name_of_your_app]

4. Environmental Setup:
	-Choose your Code Editor
		1. Sublime
		2. Visual Studio Code

----------Create React App----------

>>> npx create-react-app [name_of_your_app]
	//command to create the react application
	//remember to disable your antivirus before running this command

>> npm start
	//command to display the app on the browser.

The Folder React created:
-Inside the folder there are two main folders:
	1. src
		- this is the source folder where all of the react code that was written for our application lies.

	2. public
		-this is a public folder where all those files where our browser needs an older version of JavaScript and HTML to understand.

* When we save our code, what it's going to do is it's going to turn all of the react code in our source folder into that version that the browser understands and put it inside of this public folder.

Inside App.js file:
	- all the HTML displayed on the browser is in App.js in JSX format.
		-how this works is that when we look at the index.js, it imports the App function from App.js.

		Then there's this reactDOM library that calls render and it renders our App function in the form of what looks like an HTML tag (JSX). 

		Then there's this document.getElementById('root') which is looking on the document object for some elements with an id of "root" and it's replacing it with the App function that returns HTML.

		It is going to replace that element with the id of root with all of that HTML from our function where that element with an id of "root" is inside the index.html file which is also inside the body tag and also the entry way for our application.

Diagram:

Sample Code:
In index.js file
*******************************************************************
	import React from 'react';
	import ReactDOM from 'react-dom';
	import './index.css';
	import App from './App';
	import * as serviceWorker from './serviceWorker';

	ReactDOM.render(<App />, document.getElementById('root'));
********************************************************************

Description on how React Works:

App.js (returns an HTML) -> index.js (imports App function from App.js) -> ReactDOM library (calls render to render the app function in a JSX format) ->

document.getElementById('root') [looks for an element with an id of "root" and replace it with the HTML returned by the App function] -> index.html (where the file containing the element with an id of "root").

----------React Project Setup----------

NPM - is a package manager. It initially sees a way for us to automate the process of installing, upgrading, configuring or removing any libraries that we want.

	example: installing the react app

"build script" - it optimizes the code. This will create a build folder with the optimized code in it (minified).

	-what is going to do with the "build" folder that was created after running the command "npm run build" is to take this folder and put this on the server.

create-react-app - uses Webpack and Babel.

Babel and Webpack - take our source folder.

	-Babel will make sure that all our files are gonna work on all these browsers no matter what version, no matter how old they are, how new they are.

	It will make sure that every single one of these JavaScript files is going to be understood.

	-Webpack is a module bundler. It's letting the capability to write a modular code.

React and ReactDOM 
	1. React allows us to write an HTML like syntax inside a javascript file (JSX) and it understands it because of this react library.

	2. ReactDOM interact with the DOM
		-ReactDOM allows us to use render that will grab an element from html and insert app into it.

----------Class Components----------

state - a javascript object with properties that we can access at any point of our class.

	-in order to enable to use state, the following must be present:
		1. constructor() method.
		2. super() method inside the constructor's statement block.

		* Now you can use this.state property on the class app and can now set it to something.

		Sample Code:
		***************************
		constructor() {
			super();

			this.state = {}
		}
		***************************

		* this.setState() can now be used to set the state in our class.

----------Thinking In JSX----------

* The attributes of JSX is not always the same as HTML like "className" in JSX instead of "class" in HTML.

* All of the JavaScript expressions are enclosed with curly braces.

* The reason why setState() is used when changing the state's value is it because we are "Updating" the state not modifying it automatically.

* Everytime the state changes, it rerenders the component with the new state.

* JSX is trying to mimic HTML so with that, it can create the virtual DOM and breakdown each part of the app into components that keep getting rerendered as we update the state using the setState().

----------Dynamic Content----------

* Unique key for list of items
	-React wants to know what element needs to be updated when we iterate a list of items and display it on the browser.

	Sample code:
	*******************************
	object = [
		{
			id: '',
			item_name: ''
		},
		{
			id: '',
			item_name: ''
		}
	];

	...

	<h1 key={ object.id }> { object.item_name } </h1>
	********************************

* React is smart enough to know that if only one element in a list of a thousand elements changes, it only needs to rerender the part of the HTML that matters and not the whole thing.

----------Single Page Application (SPA)----------

* Instead of having to communicate back and forth with the server, it doesn't need to go back and just have a javascript or react that rerender the DOM with something else.

* Instead of requesting a page, it's turn more into requesting for data.

* This makes it possible to communicate with outside servers. 

----------Fetching Content----------

Life Cycle Methods
	-methods that are called at different stages of when component gets rendered.

	Some Methods:
		componentDidMount()

fetch() 
	-make an API request that returns a promise.

	Sample Code:
	******************************
	componentDidMount() {
		fetch('https://jsonplaceholder.typicode.com/users')
		.then(response => response.json())
		.then(user => console.log(user))
	}

----------Architecting Our App----------

For Component Preferences:
	1. All components should be stored in a folder named "components"

		1.1. The component files for style and jsx.
			* Under the ComponentName folder:
				componentName.component.jsx
				componentName.styles.css

			* Sample Architecture:
				components/card/card.component.jsx
				components/card/card.styles.css

----------Focusing on Components----------

prop - an object of any properties that you write onto a component where it gets used.

children - one of the main properties that exists on props object.
		 - it is what is pass in between the brackets of our component that gets called.

		 example: 
		 In App.js:
		 ******************************
		 <Component propName="someValue">
		 	<h1>Some Value</h1> 
		 	//this is a child of a component
		 </Component>

		 ...

		 In ComponentName.component.jsx:
		 export const CardList = props => {
		 	return <div>{ props.children }</div>
		 };

		 *******************************

		 -it gets attached to the actual class as a property called Props.

----------Breaking Into Components----------

Question:
	When do we break things down into components?

Answer:
	When we break things down we're making things more flexible because each component does one thing so that it can be used in other places. 

	To simplify complex logic.

	Flexibility of performance and components that are easy to test because they're so simple.

	The reason we break things down into smaller and smaller components is that we combine each component with its concern and that concern is that this component is only concerned about its uses.

----------State vs Props----------

State usually live in one location and it trickles down as props.

Everytime the state changes it will pass on to the components who need it and will rerender itself with the new prop information and display the new rendered component to the browser.

----------More On State----------

setState() is asynchronous.

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Synchronous vs Asynchronous:

Synchronous 
	-is something that we can expect to happen almost immediately. JavaScript will wait for the action to finish before it continues.
Asynchronous
	-is something that actually takes an indefinite amount of time that JavaScript does not know.

	-what it does is it actually runs the rest of the code after and then when the asynchronous event finishes, it then runs that finished event.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

setState has a second argument and it is a callback function.  

----------React Events----------

React SyntheticEvent

Synthetic Events like: onClick, onMouseOver, etc. cannot be used as asynchronous.

----------Filtering State----------

Destructuring
	-allows us to pull properties off of an object and set them to constants that we put inside of "const { }"


array.filter() method
	* When you want to search for something like you want to search for a specific record using the searchbar on the app displayed on the browser, use this method. 

	* Make sure to lowercase everything and use .includes() method to check that the user inputted value match with your database/local storage/arrays or something.

	Sample Code:
	*******************************************
	this.state = {
		users: '',
		searchField: ''
	};

	...

	/*Destructuring*/
	const { users, searchField } = this.state;

	/*Equivalent way instead of Destructuring*/
	const users = this.state.users;
	const searchField = this.state.searchField;

	const users = users.filter(user => {
		user.name.toLowerCase().includes(searchField.toLowerCase())
	});
	*******************************************

Sample Scenario using Searchbar:
	When you input something on the searchbar, it will trigger the synthetic event called "onChange" which will capture all the events of what you inputted on.

	It will then call the setState to set the new State which will rerender the components afterwards.

	When it rerenders, it (re)filters the records/lists of record using array.filter() to filter the records that meet with what you want to search for.

	The filtered value will be stored in a constant which will be passed to the component as a prop and rerender that component and display the new changes on the browser with the new prop information.

----------More on Component----------

Functional Components
	-they don't have access to the state because they don't have access to the constructor which is a class method on our component that we import from react that we extend our class from.

	-they don't have internal state and lifecycle methods because they don't always need to use lifecycle methods or internal state.

	-sometimes all we want to do is render some HTML and that's what a functional component really is.

	-unlike class component, a functional component is just a component that gets some props and returns some HTML.

	* The main thing to remember is if you don't think that you need internal state nor access the lifecycle methods then just use a functional component because it's easier to read and easier to test and in some ways smaller and easier to reason about.


----------Where To Put State----------

* You may want to move the state in high enough position so that we are still able to pass down that information to different nodes.

----------Class Methods and Arrow Functions----------

"this" keyword
	-special keyword in JavaScript that references the context in which it's being invoked.

	*If we want to write our own method, to represent our own (custom) method we would have to be careful about how we write it.

"bind" function
	- is a method on any function that returns a new function where the context of "this" keyword is set to whatever we passed to it and the context of "this" that we're setting in handle change is the "this" keyword that is defined inside of our constructor which knows that it's our component.

* When JavaScript first created our app component, it also defined all of the methods on our components including your custom method/function. And it understands that this custom method is an arrow function. When this arrow function came into existence to JavaScript, it was going to bind any references to "this" inside of it to the context in which it was defined which is our app component.

Sample Code:

*********************************************
constructor() {
	super()
	this.state = {
		...
	};

	this.handleSearchChange = this.handleSearchChange.bind(this);
	//in order not to use this way, it needs to use ES6 arrow function just like below the scope of this class method code.
}

...

//this is a lexical scoping 
//this doesn't need to use the above code.

handleSearchChange = (event) => {
	this.setState({...})
}

******************************************

----------Deploying the App on Github----------

1. Go to Github and add repository and write the name of the app on the project name

2. Copy the link

3. Go to cmd and locate your project directory

4. git remote add origin [paste the link here]
   /*write this command on the console*/

5. npm install gh-pages
   /*write this command on the console*/

6. Go to the package.json file and add the following properties:

	"homepage": "https://[your github_username].github.io/[name_of_repo]",

	"scripts": {
	    "predeploy": "npm run build",
	    "deploy": "gh-pages -d build"
	}

6. npm run deploy
   /*write this command on the console*/

7. git add -A
   /*write this command on the console*/

8. git commit -m "adding files for github pages"
   /*write this command on the console*/

9. git push origin master
   /*write this command on the console*/
   


----------Vitual DOM + Unidirectional Data Flow----------

Virtual DOM
	- is just a complete copy of this actual DOM but in JavaScript.

	-whenever we update any of the data that ends up being rendered in our components,
	react doesn't rerender the entire DOM. It only wants to affect the thing that matters.

		* So what react does is it actually copies the virtual DOM except this time it's going to apply the changes with the data that got updated so the new state will be changed and apply the changes to that specific component that needs changes without affecting the other components.

		* It's going to apply those changes to the copied virtual DOM. And what react will do is it will compare this new virtual DOM to the actual DOM and apply the changes to the actual DOM as it sees changes (It will only apply to the node that needs changes).

		Diagram:
		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


					Views
				   /\   \
				   /	 \
				  /		  \
				 /		   \
			    /		    \
			   /			 \
			  /				  \
			 /				   \
			/				    \
		   /  				    \/
  		 State <------------- Actions

  		 Description:
  		 	When the state changes, it will pass the data as props to the components that needed it. These components then will rerender and apply the changes with the new data.

  		 	Any user actions that will be made in these components will trigger an action that will update the state and then the process continues.

  		 	This process is what we called "Unidirectional Data Flow"

  		^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

----------React LifeCycle Methods - Mounting----------

By Order Cycle when Mounting:
	
	-----Render Phase----
	(Pure and has no side effects. May be paused, aborted or restarted by React)

	1. constructor()
	2. render()

	-----Commit Phase----
	(Can work with DOM, run side effects, schedule updates)

	2.1. React updates DOM and refs
	3. componentDidMount()


----------React LifeCycle Methods - Updating----------

By Order Cycle when Updating:

	-----Render Phase----

	1. New props, setSate(), forceUpdate() 
	1.1. shouldComponentUpdate()
	2. render()

	-----Commit Phase----

	2.1. React updates DOM and refs
	3. componentDidUpdate()

	Sample Code for:

		shouldComponentUpdate():
		***********************************************

		shouldComponentUpdate(nextProps, nextState) {
			return nextProps.text !== this.props.text;
		}

		***********************************************

		* We use this lifecycle method for performance purposes because as the state changes but with the same data or any conditions that you want to be met, it will still render the components with the same state that will be passed as props which is a waste of performance.


----------React LifeCycle Methods - Unmounting----------

By Order Cycle when Unmounting:

	-----Commit Phase----

	1. componentWillUnmount()

	* This is usually use for avoiding data leakage.

*******************************************************
Chapter #4: Master Project Setting Up E-commerce Project

----------E-commerce Homepage + Sass Setup----------

>>> npm install node-sass
//to install the upgraded version of CSS

* Package lock files
	- allow us to have consistent installs across machines so that all these dependencies have the exact version number that they need in order for everything to work.

* "pages" folder in React App
	-Any components that can only be used once unlike reusable components that are stored in the "components" folder.

* `` this is a string interpolation. This is used when you want to combine string and javascript expression with ${...some expression}. 

* When you want to add a link element on your html used for font-styling and etc., add it on "index.html" under public folder.

* When you want to apply a font to all parts of your app, apply css on App.css

*************************************************

CHAPTER #5: Master Project React Router and Routing


>>> npm install react-router-dom
	/*this will allow to handle routes*/

	//import this in index.js file like this and wrap the App component with it's component:

	In index.js
	*******************************************
	import { BrowserRouter } from 'react-router-dom';

	import './index.css';
	import App from './App';

	ReactDOM.render(
		<BrowserRouter>
			<App />
		</BrowserRouter>
		//this gives all the functionality of ReactRouter library to our app
		, document.getElementById('root'));
	*******************************************

	...

	In App.js
	*******************************************
	import { Switch, Route } from 'react-router-dom';

	class App extends Component {
		render() {     
			return (
				<div>
					<Switch>
						<Route exact path='/' component={ HomePage }/>
						<Route path='/hats' component={ HatsPage }/>
					</Switch>
				</div>
			);
		}
	}
	*******************************************

	The main properties of Route component(some of attributes):

		1. component
			- this is the component that will be rendered when routing to other page

		2. path
			- will be a string that's equal to the path itself from the current place and all.

		3. exact
			- this is a true or false property. The default value is true.
		    * The “exact” prop is important because I only want this Route to render when the URL is exactly “/”.
			If the exact prop was not on the Route component, all Routes starting with a “/” such as “/todos/new” would evaluate to true for that Route, when they really shouldn’t in this case.

	-------
	The Switch component:
		- wraps the Route component(s).
		- what it does is the moment that a route inside of it finds a match in the path, it does not render anything else but that route.
		- this is an equivalent of switch statement in JavaScript

------------React Router Dom------------

Route component passed the following props that can be used by the component that is being rendered in the routing process:

	1. history
		- contains the following properties:
			1. push
				- this allows to redirect page.

				example:
					*******************************************
					<button onClick={ () => props.history.push('/topics') }> Topics </button>
					*******************************************


				* You can use Link component with "to" property (to redirect to specific route) from react-router-dom instead of push:

				example code:
					*******************************************
					import { Link } from 'react-router-dom';

					<Link to='/topics' />
					*******************************************

	2. location
		-contains the following  properties (some):

			1. pathname
				- has the full pathname.

	3. match
		- contains the following properties:
			1. isExact
				- if the path is match with the route

			2. params
				- any parameters you passed on the url like an "id".

			3. path
				- the path for that route

				example:
					path: "/topics/:id"

			4. url
				- the actual url with all explicit values of all parameters.

				example:
					url: "/topics/13"


------------withRouter------------

- it is a higher order component
* Higher Order Component
	- is essentially a function that takes a component as an argument and returns a modified component.

-is a function that gives all of the things that the route component has like: history, location, match as props.

************************************************

CHAPTER #6: Master Project Forms + Components


* Any format of images like svg will be stored in a separate folder named "assets".

* ReactComponent - a special syntax in React for importing SVG.

--------Sign In Component----------

* If you want to set state dynamically, wrap the state property in a bracket like this:

	Sample Code:
	*********************************************
		handleChange = event => {
			const { name, value } = event.target;

			this.setState({ [name]: value });
		}
	*********************************************

******************************************************
CHAPTER #7: Master Project Firebase + User Authentication


--------Adding a Project to Firebase--------

1. Go to Firebase
2. Go to Console
3. Add project
4. Project Overview
5. Web
6. Add nickname and continue
7. Copy the Firebase configuration
8. Go to the terminal and type the following command:
|	npm install firebase
9. Go to your React project and create a folder named "firebase" under src folder.
10. Create a file with filename "firebase.utils.js".
	
	Write the code below:
    **************************************
	import firebase from 'firebase/app';
	import 'firebase/firestore';
	import 'firebase/auth';

	const config = {
	    apiKey: "AIzaSyC_jdWXsjJRziIRDUB9WlT_vlUldWUDKQk",
	    authDomain: "crwn-db-ea6c0.firebaseapp.com",
	    databaseURL: "https://crwn-db-ea6c0.firebaseio.com",
	    projectId: "crwn-db-ea6c0",
	    storageBucket: "crwn-db-ea6c0.appspot.com",
	    messagingSenderId: "277706239604",
	    appId: "1:277706239604:web:b731a488ddd0b2c3162b21",
	    measurementId: "G-ZTT9N8HNXL"
  	};

  	firebase.initializeApp(config);

	export const auth = firebase.auth();
	export const firestore = firebase.firestore();

	const provider = new firebase.auth.GoogleAuthProvider();
	provider.setCustomParameters({ prompt: 'select_account' });
	export const signInWithGoogle = () => auth.signInWithPopup(provider);

	export default firebase;

    **************************************
11. Go to firebase page and go to Authentication.
12. Go to Sign-in method tab
13. Enable google provider
14. import auth on the App.js
15. Open and Close Authentication by writing the following:

	Sample Code:

	App.js
	*****************************************
	unsubscribeFromAuth = null;

	componentDidMount() {
		this.unsubscribeFromAuth = auth.onAuthStateChanged(user => {
			this.setState({ currentUser: user });

			console.log(user);
		});
	}

	componentWillUnmount() {
		this.unsubscribeFromAuth();
	}
	*****************************************
------Firebase Signout-------
16. Go to the component where your signout button will be placed.
17. import the auth from firebase and make use of 'signOut()' function from auth.

	Example:
	*****************************************
	<div className='options'>
		<Link className='option' to='/shop'>
			SHOP
		</Link>
		<Link className='option' to='/shop'>
			CONTACT
		</Link>
		{
		
		//the currentUser is the prop that is passed to this component which is the current user that might be logged in at the moment.

		currentUser ? 	
			<div className='option' onClick={() => auth.signOut()}>
				SIGN OUT
			</div>
		:	<Link className='option' to='/signin'>SIGN IN</Link>
	}
	</div>
	*****************************************

-------------Firebase Firestore-------------

1. Go to firebase console.
2. Click Database
3. Create database
4. Click continue and Done
5. Start a collection (NoSQL - List of objects)
Note:
	The users that signin using google is still in the Authentication. It is still not stored on a database so don't forget to set it up!

-------------Storing User Data In Firebase-------------

-Storing data in our database (firestore).

QueryReference and QuerySnapshots
------------
Query - is a request we make to firestore to give us something from the database.

Firestore returns us two types of objects: 
	1. references
	2. snapshots

	Of these objects, they can be either Document or Collection versions

Firestore will always return us these objects, even if nothing exists at from that query.
------------

queryReference object 
	- is an object that represents the "current" place in the database that we are querying.

	We get them by calling either:
		firestore.doc('/users/:userId');
		firestore.collection('/users');

	It does not have the actual data of the collection or document. 

	It instead has properties that tell us details about it, or the method to get the Snapshot object which gives us the data we are looking for.




... Continuation
6. In firebase.utils.js, write the following:

	firebase.utils.js
	*******************************************
	export const createUserProfileDocument = async (userAuth, additionalData) => {
		if(!userAuth) return;

		//this is for testing purposes if it gets the queryReference with the manually created userId
		console.log(firestore.doc('users/1435hghhhjh'));
	}
	*******************************************
	
-------------------
DocumentReference vs CollectionReference

We use documentRef objects to perform our CRUD methods (create, retrieve, update, delete). The documentRef methods are:
	1. .set()
	2. .get()
	3. .update()
	4. .delete()

We can also add documents to collections using the collectionRef object using the .add() method. 

	Example:
		collectionRef.add({value: prop})

We get the snapshotObject from the referenceObject using the .get() method ie. documentRef.get() or collectionRef.get()

documentRef returns a documentSnapshot object.
collectionRef returns a querySnapshot object.




...Continuation
7. Under the config object, write this method which will allow to store the user data in the firebase's firestore (database):

	firebase.utils.js
	*************************************************
	export const createUserProfileDocument = async (userAuth, additionalData) => {
		if(!userAuth) return;

		/***************************************************************
		selects the document reference to a specific user through auth.uid that is passed on the App.js as an argument
		***************************************************************/

		const userRef = firestore.doc(`users/${userAuth.uid}`);

		/****************************************************************
		gets the document snapshot from the document reference using the .get() method
		****************************************************************/

		const snapShot = await userRef.get();

		/****************************************************************
		this creates a user data if there is no existing data on this documentRef under userRef.
		****************************************************************/

		if(!snapShot.exists) {
			/****************************************************************
			deconstruct the properties from auth.
			****************************************************************/

			const { displayName, email } = userAuth;
			const createdAt = new Date();

			try {
				/*************************************************************
				create the data using .set() method
				*************************************************************/
				await userRef.set({
					displayName,
					email,
					createdAt,
					...additionalData
				});
			}
			catch(error) {
				console.log('error creating user', error.message);
			}
		}
		/***************************************************************
		returns the queryReference object for future used on the App.
		***************************************************************/
		return userRef;
	}

-----------Storing User Data In Our App-----------

-Storing data to the "state" of our application so we can use it in our app.

---------------------

DocumentSnapshot vs. QuerySnapshot

DocumentSnapshot
	- We get a documentSnapshot object from our documentReference
	object.
	- The documentSnapshot object allows us to check if a document exists at this query using the .exists property which returns a boolean.
	- We can also get the actual properties on the object by calling
	the .data() method, which returns us a JSON object of the document. 

QuerySnapshot
	- We get a querySnapshot object from our collectionReference object.
	- We can check if there are any documents in the collection by calling the .empty property which returns a boolean.
	- We can get all the documents in the collection by calling the .docs
	property. It returns an array of our documents as documentSnapshot
	objects. 


...Continuation
8. In App.js write this code:
	
	App.js
	********************************************
	componentDidMount() {
		this.unsubscribeFromAuth = auth.onAuthStateChanged(async userAuth => {
			/******************************************
			If user authentication object exists, pass the auth to createUserProfileDocument() function and set the current user state to the signed in user details.
			******************************************/
			if(userAuth) {
				const userRef = await createUserProfileDocument(userAuth);

				userRef.onSnapshot(snapShot => {
					this.setState({
						currentUser: {
							id: snapShot.id,
							...snapShot.data()
						}
					});
				});
			}
			else {
				/******************************************
				If user authentication object is null, then set the current user state to null;
				******************************************/

				this.setState({ currentUser: userAuth });
			}
		});
	}
	********************************************

----------Sign Up Component---------------

createUserWithEmailAndPassword() method
	- creates a new user account associated with the specified email address and password.
	- this method is a property of firebase auth which can be called and used directly.



...Continuation
9. In SignUp component write this code for the handleSubmit function that handles onSubmit():
	
	sign-up.component.jsx
	*****************************************************
	handleSubmit = async event => {
		event.preventDefault();

		/*********************
		Deconstruc the properties from the state object
		**********************/

		const { displayName, email, password, confirmPassword } = this.state;

		/*********************
		Checks if passwords match
		**********************/

		if(password !== confirmPassword) {
			alert("passwords don't match");
			return;
		}

		try {
			/*********************
			Deconstucts the user property returned by auth after creating a user using .createUserWithEmailAndPassword() built-in auth method.
			**********************/

			const { user } = await auth.createUserWithEmailAndPassword(email, password);

			/*********************
			Storing data to the firestore
			*********************/
			await createUserProfileDocument(user, { displayName });

			//This will clear the form fields
			this.setState({
				displayName: '',
				email: '',
				password: '',
				confirmPassword: ''
			});
		} catch (error) {
			console.log(error);
		}
	};
	*****************************************************

-------------Sign In With Email and Password-----------

signInWithEmailAndPassword() method
	- asynchronously signs in using email and password
	- this method is a property of firebase auth which can be used directly.



...Continuation
10. In SignIn component write the following for the handleSubmit method:

	sign-in.component.jsx
	*************************************************************
	handleSubmit = async event => {
		event.preventDefault();

		const { email, password } = this.state;

		try {
			/*************************************************
			passing email and password to firebase auth .signInWithEmailAndPassword() method with await which waits for the promised to be returned
			***************************************************/

			await auth.signInWithEmailAndPassword(email, password);

			/*************************************************
			clears the form fields when the form submits
			***************************************************/

			this.setState({ email: '', password: '' });

		} catch (error) {
			console.log(error);
		}
		
	}
	*************************************************************
***************************************************
CHAPTER #8: Master Project Redux 1

--------Redux Introduction----------

- is a state management system to manage the application's large state as it grows and become more complex to handle.

--------Redux Concepts----------

Why Redux?
	- Good for managing large state
	- Useful for sharing data between components
	- Predictable state management using the 3 principles:
		1. Single source of truth
		2. State is read only
		3. Changes using pure functions

Redux Flow:
Action -> Root Reducer -> Store -> DOM changes

	Definitions:
		Action
			- any actions on the app
		Root Reducer 
			- is a pure function that receives an input which is the action that creates an output -- which is the store (state).
		Store
			- the "state" in redux.

Redux uses an Architectural Pattern called:

Flux Pattern:
Action -> Dispatcher -> Store -> View

- it makes sure to solve problems in a logical sense and in an organzied fashion. 

	Pattern Description:
		- the pattern has an action which will be dispatch with a dispatcher to the store which updates the view.
		- this pattern is one-way data flow that is if the view gets updated, everything will start to the action and the process continues to changing the view.
		
Caveat:
	We keep a little bit of React state in a component.
	Redux doesn't replace the "this.state" completely
		Note: 
			This is a common pattern to keep only important state in Redux Store while keeping UI specific state like form inputs in "this.state".

--------Redux In Our Application----------

Redux solves the problem of prop-drilling.

Prop-drilling
	- to pass the state from Component to the child components who need it even though those component that is part of the tunneling doesn't need it.

	Diagram:
		App Component
			state: {
				currentUser: {}
			}
		------------------------------------------
			|
			Pass currentUser as prop
			V
			V
		------------------------------------------

		Header Component 
		(has the prop but doesn't really need it, but just passed it to the Cart Component who really needs it).

		------------------------------------------
			|
			Pass currentUser as prop
			V
			V
		------------------------------------------

		Cart Component 
		(the component who needs the currentUser)

Redux Overall Flow:

									----------------------------------------------------Pass State As Props------------------------------------------------------
									|																		  |                       |                         |
									|																		  |						  |					        |
									|																		  |						  |							|
  -----------------------------> Root Reducer <------------------------------								  |						  |							|
  |			                    (App State)  								|								  |						  |							|
  |									^										|								  |						  |							|
  |									|										|								  |						  |							|
  |									|										|								  V 					  V 					    V
Home Reducer					Shop Reducer						 User Reducer                         Component               Component               Component
(Slice of State)				(Slice of State)					(Slice of State)                          |                       |                         |
	^								^										^								  |					      |							|
	|								|										|								  |						  |							|
	|								|										|								  |					      |							|
Update Reducer				 Update Reducer						     Update Reducer							  |						  |							|
	|								|										|								  |						  |							|
	|								|										|								  |						  |							|
    -------------------------------------------------------------------------								  |						  |							|
    								|																		  |						  |							|
    								|																		  v						  v 						v
    								------------------------------------------------------------Actions <---------------------------------------------------------





-----------Redux Actions and Reducers------------

Redux Actions in Diagram:

	---------------Pass currentUser as prop--------------------
	|														  |
	|														  |
	|														  V
	|												      Component
	|														  |
	|														  |
User Reducer											  	  |
{											trigger action -> SET_CURRENT_USER
	currentUser: {}										      |									
}														      |
	^														  |
	|														  |
	|														  V
	|												{type: string, payload: any}
	|														  |					
	|														  |
	----------Update User Reducer with payload-----------------

	Description:
		- When action takes place from a component, it triggers an action through a
		function with parameters: type, payload.
		- This function will update the reducer of that specific component 
		(e.g. User Reducer - which holds the state of the currentUser). which will then
		change the store and make changes on the View.

---------------
Root Reducer content Sample:
	{
		User Reducer: {},
		Home Reducer: {},
		Cart Reducer: {}
	}

	Description:
		- The root reducer holds all the App's reducers in an object.
		- Each reducer is in a form of object also.

-----------
Reducer Sample Code:
	***********************************************
	/* 
	The currentState is the state before an action takes place
	*/

	const userReducer = (currentState, action) => {
		switch(action.type) {
			case 'SET_CURRENT_USER':

				/*
				Returns a new object to rerender the component
				*/

				return {
					...currentState,
					currentUser: action.payload
				};

			default:
				return currentState;
		}
	}
	***********************************************
	Explanation:
		- The reducer is a function that takes a state and it takes an action.
		- The state is the previous state that it was in. It is the state before the new action is going to update it. 
		- This function returns an new object and that object is going to be the new state of our User Reducer.
		- It uses a switch statement to check the action's type.
		- The reason why it returns a new object is because we want the component to re-render. That is how React Components works.
		- React Components only re-render if their props are different and the only way that the props are different is if the object that it has is NEW.

-----------Setting Up Redux-------------

Middleware 
	- is a piece of code that gets the action before the root reducer.
	- receives these action objects before they reach the root reducer.

	Redux Logger Middleware:
		- a middelware that logs out actions that gets fired.
		- a visual representation of what it is that actions do.

1. Install redux, react-redux, and redux-logger middleware:
| npm install redux react-redux redux-logger

2. Go to index.js. This is where we import react-redux that will give our application access to not only the store but also those reducers that we also going to write.

Provider
	- a component from react-redux.
	- is a component that we want to wrap around the entire application because we want everything inside to have access to this store object that we get from redux.
	- is a component that is the parent of everything inside of our application.

	Codes:
	index.js
	*************************************
	import { Provider } from 'react-redux';

	ReactDOM.render(
		<Provider>
			<BrowserRouter>
				<App />
			</BrowserRouter>
		</Provider>
		, document.getElementById('root'));
	*************************************

3. Make a folder named "redux" under src folder.
	- All the code related to redux will be stored here.

4. Write a file named "root-reducer.js" under redux folder.
	- this is where the actual code that combines all of our other states together is placed.

5. Write each reducer in a separate file under its own folder name:
	Example Format for User Reducer:
		redux/user/user.reducer.js

Note: 
	- When we actually fire the state for the first time, it's going to be nothing. 
	- We need to set an initial state for this reason.

Caveat:
	- Every single reducer gets every single action that ever gets fired even those actions are not related to this reducer.

6. One of your reducer might look like this:

	Sample Code:

	user.reducer.js
	**********************************************
	const INITIAL_STATE = {
		currentUser: null
	}

	const userReducer = (state = INITIAL_STATE, action) => {
		switch (action.type) {
			case 'SET_CURRENT_USER':
				/* The new user is stored in the payload. */
				return {
					...state,
					currentUser: action.payload
				}
			default:
				return state;
		}
	}

	export default userReducer;
	**********************************************

7. Go to your root-reducer.js and import your reducers here to combine them altogether by using the "combineReducers" component from redux.

	Sample Code:

	root-reducer.js
	**********************************************
	import { combineReducers } from 'redux';

	import userReducer from './user/user.reducer';

	const rootReducer = combineReducers({
		user: userReducer
	});
	export default rootReducer;
	**********************************************

8. Create a file named store.js under redux folder
   Write the following code:

   		store.js
   		*******************************************
   		import { createStore, applyMiddleware } from 'redux';
   		import logger from 'redux-logger';

   		import rootReducer from './root-reducer';

   		/*
   		Middlewares are stored in an array so if another middleware will be used, it will be added in the array.
   		*/

   		const middlewares = [logger];

   		/*
   		We instantiated the store using the createStore function that accepts root reducer and applyMiddlware function as arguments.

   		The applyMiddleware function allow us to apply middleware in our store.
   		*/

   		const store = createStore(rootReducer, applyMiddleware(...middlewares));

   		export default store;

   		*******************************************

   		Note:
   			- We apply middleware in our store so whenever actions gets fired or dispatched, we can catch them and then display them.
   			- Middleware is just functions that receive actions in and then do something with them and then pass them out into the root reducer.
   			- logger is a middleware imported from redux-logger.

9. Go to index.js and import and pass the store as prop to the Provider component.

	- Moreover, we can dispatch function to the store or we can actually pull values off of the store and into our components as we pass the store.

	index.js
	*********************************************
	import store from './redux/store';
	*********************************************

10. Create a file named "user.actions.js".
	Note:
		- All codes in here are used as an action creator which will be used by the reducer;

	Sample Code:
	user.actions.js
	*********************************************
	export const setCurrentUser = user => ({
		type: 'SET_CURRENT_USER',
		payload: user
	});
	*********************************************

...continuation to the next topic.

---------connect() and mapStateToProps-----------

...Continuation

11. Locate the component that needs redux store and import connect into that component.

	Sample Code:
	header.component.jsx
	*****************************************
	import { connect } from 'react-redux';

	*****************************************

	Sample Scenario:
		- We know conceptually that we need to bring our user reducer as current user value into where we need it which will be our header component because it is still getting the current user from app.js and we don't want that.
		- What we want is to pull that current user value off of our reducer.
		- In order to make that happen, we need to import connect.

	Notes:
		Connect 
			- is a higher-order component that lets us modify our component to have access to things related to redux.
			- connect's first argument is going to be the function that allows to access the states. It is the state being our reducer -- our root reducer to be specific.

		Higher-Order Components
			- are just functions that take components as arguments and then return you a new souped-up component.

12. Do the following to access things related to redux with connect.

	Sample Code:
	header.component.jsx
	******************************************
	const mapStateToProps = (state) => ({
		currentUser: state.user.currentUser
	});

	export default connect(mapStateToProps)(Header);
	******************************************

	mapStateToProps
		- it returns an object where the name of the property will be the actual property (props) that we want to pass in and then the value will be the value.
		- it accepts an argument which is a state object. This state is the root reducer.
		- this function will be passed as the first argument of "connect".

13. [Optional]
	Go to App.js and remove the prop that is passed in to the Header component because redux has been implemented it there and there is no need for that prop that results to prop-drilling.


...continuation
-----------mapDispatchToProps-----------

...Continuation
Here we need to update our app component so that it's able to update the reducer value with the new "setCurrentUser" action that is made.

14. Go to App.js and import connect so this component can access things related to redux.

	Code:
	App.js
	*****************************************
	import { connect } from 'react-redux';

	class App...{
	...
	}
	const mapDispatchToProps = (dispatch) => ({
		setCurrentUser: user => dispatch(setCurrentUser(user))
	})

	export default connect(null, mapDispatchToProps)(App);
	*****************************************

	Notes:
		- The first argument of connect is "mapStateToProps" and the second argument is "mapDispatchToProps".
		- The first argument has null value because it doesn't need any "state to props" from our reducer.
		- The second argument is the mapDispatchToProps which is a function that gets this dispatch property and similarly will return an object where the prop name will be whatever prop we want to pass in that dispatches the new action that we're trying to pass which is "setCurrentUser".

15. import the setCurrentUser from user.action.js so it can be dispatch to pass the action to the reducer.

	Sample Code:
	App.js
	*******************************************
	import { setCurrentUser } from './redux/user.action';

	class App...{
	...
	}
	const mapDispatchToProps = (dispatch) => ({
		setCurrentUser: user => dispatch(setCurrentUser(user))
	})

	export default connect(null, mapDispatchToProps)(App);
	*******************************************
	Notes:
		- What will end up returning from the function is the "setCurrentUser" that will become one of the Props of this component. This property is a function that gets the user object and then calles the "dispatch" function.
		- dispatch()
			- it is a way for redux to know that whatever object is passing to redux is going to be an action object that it is going to pass to every reducer.
			- inside dispatch, the action will be called and going to pass that data object -- user object(as an example).
			- We are invoking setCurrentUser with the user (the data object) that will then be used as the payload in our reducer.

	- Remove the constructor because it is not needed anymore to set the state of our app.

	- Check the console and you'll see the redux-logger logging the action that gets fired. There are three sections in redux-logger:

		1. prev state
			- it is the state before the action gets fired.

		2. action
			- it is the action that gets fired.

		3. next state
			- is the state after the action modified the reducer.

------------User Redirect and User Action Types---------

Scenario 1:
	If the user signs in, they are still able to access the signin page which we don't want to happen because they are still able to trigger any of the code in our signin and mess with the firebase flow and we don't want that.

Solution:
	- When the user signs in, we redirect the user to the home page.
	- We need 2 things to implement: 
		1. Redirect Component
		2. Current user redux state

Implementation:
	1. import the Redirect component from react-router-dom library.

	2. write the mapStateToProps function just like in the header component.

		Sample Code:
		App.js
		***********************************
		import { Redirect } from 'react-router-dom';

		class ... {
		...
		}

		const mapStateToProps = ({ user }) => ({
			currentUser: user.currentUser
		});

		export default connect(mapDispatchToProps, mapStateToProps)(App);

		***********************************
		Notes:
			- On the signin route, put on an exact property and remove the component property.
			- Put on a render property like this:

			App.js
			**************************************************
			<Route 
				exact 
				path='/signin' 
				render={() => 
					currentUser ? 
						<Redirect to='/'/> 
					:	<SignInAndSignUpPage />
				}
			/>
			**************************************************
			Explanation:
				When the currentUser data is available and not null, after the user signs in, it will redirect to the home page else it will go back to Signin and Signup Page.

...Continuation
Scenario 2:
	- In user.actions.js, the "type" property is a hard-coded string. In our reducer we're referencing the same string but the best practice is to make sure that it's consistent in any place that might be referencing this string.

16. Create a file named "user.types.js" under user folder and create the string constant under variable name called "UserActionTypes" and export it just like this:
	Code:
	user.types.js
	********************************************
	export const UserActionTypes = {
		SET_CURRENT_USER: 'SET_CURRENT_USER'
	};
	********************************************

	and import this to user.reducer.js and user.action.js like this:

	Code:
	user.actions.js and user.reducer.js
	********************************************
	import { UserActionTypes } from './user.types'; 

	const userReducer = (state = INITIAL_STATE, action) => {
		switch (action.type) {
			case UserActionTypes.SET_CURRENT_USER:
				...
		}
	}
	********************************************
	

---------Implementing Redux in Cart-----------

Scenario:
	Toggling Component (hide and show) when user clicks on it.

Solution 1 (Toggled component is only used in one component)
	- When the component only toggles in only one component, then just do a local state with property "hidden" of boolean value.
	- Define a function which will handle the event that will change the state.
	- Implement a ternary operator which will check if the "hidden" state property is true or false.
	  If it is true then just return "null" else, return the component (that is to display that component).

Solution 2 (Toggled component is used by more than one component)
	- Use redux to dispatch the action which will toggle the value of the store to set "hidden" property to true or false.

	Sample Code:

	redux codes:
	------------
		cart.actions.js
		**************************************
		import { CartActionTypes } from './cart.types';

		export const toggleCartHidden = () => ({
			type: CartActionTypes.TOGGLE_CART_HIDDEN
		});
		**************************************

		...

		cart.reducer.js
		**************************************
		import { CartActionTypes } from './cart.types';

		const INITIAL_STATE = {
			hidden: true
		};

		const cartReducer = (state = INITIAL_STATE, action) => {
			switch (action.type) {
				case CartActionTypes.TOGGLE_CART_HIDDEN:
					/*
						Returning the action's payload is optional. The "hidden" property toggles to true or false every time the action gets dispatch.
					*/
					return {
						...state,
						hidden: !state.hidden
					}
				default:
					return state;
			}
		};
		export default cartReducer;
		**************************************

	components code:
	----------------

		cart-icon.component.jsx
		**************************************
		const CartIcon = ({ toggleCartHidden }) => (
			<div className='cart-icon' onClick={toggleCartHidden}>
				<ShoppingIcon className='shopping-icon'/>
				<span className='item-count'> 0 </span>
			</div>
		);

		/*
			Dispatches the action that will update the cart reducer
		*/

		const mapDispatchToProps = dispatch => ({
			toggleCartHidden: () => dispatch(toggleCartHidden())
		});

		export default connect(null, mapDispatchToProps)(CartIcon);
		**************************************

		...

		header.component.jsx
		**************************************
		const Header = ({ currentUser, hidden }) => (
			<div className='header'>
				...

				/*
					If hidden is false, it will display the CartDropdown component
				*/

				{ hidden ? 
					null : (
						<CartDropdown />
					)
				}
				
			</div>
		);

		const mapStateToProps = ({user: { currentUser }, cart: { hidden } }) => ({
			currentUser,
			hidden
		});

		export default connect(mapStateToProps)(Header);
		**************************************


-----------Cart Items Management-----------
Scenario 1:
	Clicking "Add to cart" button to add item(s) to the cart items in redux.

Solution:
	1. Handle the click event when user clicks on the "Add to cart" button.
	
	2. Managing the CartItems list:
		1. Initialize the value of cartItems to empty array.
		2. To store items to the cartItems, just do something like this:
			Sample code:

			cart.reducer.js
			*******************************************************
			const INITIAL_STATE = {
				hidden: true,
				/*
					Cart items initialization to empty array.
				*/
				cartItems: []
			};

			const cartReducer = (state = INITIAL_STATE, action) => {
				switch (action.type) {
					...
					case CartActionTypes.ADD_ITEM:
						/*
							Spread the current lists of cartItems and then add the new payload.
							This will allow to add new items to cartItems (with existing items)
						*/
						return {
							...state,
							cartItems: [...state.cartItems, action.payload]
						}
					default:
						return state;
				}
			};
			export default cartReducer;
			*******************************************************

Scenario 2:
	Grouping multiple items (the same item) in one object and add a quantity property which holds the item's quantity.

Solution:
	1. Use the utility function ".find()" to find if an item already exist in the cartItems list.

		Note: The .find() returns undefined if no item is found, else, it will return that item that meets the condition. 

		Sample Code:

		cart.utils.js
		*******************************************
		export const addItemToCart = (cartItems, cartItemToAdd) => {
			const existingCartItem = cartItems.find(
				cartItem => cartItem.id === cartItemToAdd.id
			);
		};
		*******************************************

	2. Store it in a variable and use this variable to check if the new cart item to be added in the cart items existed. If yes, then use the .map() utility function to return new object with the "quantity" property which holds the value of the existing quantity of an item:

		Sample Code:

		cart.reducer.js
		*******************************************
		...

		if(existingCartItem) {
			return cartItems.map(cartItem => 
				/*
					If the new item exist in the cartItems, it will return a new object with the cartItem properties with the new quantity of the item.
				*/
				cartItem.id === cartItemToAdd.id
					? { ...cartItem, quantity: cartItem.quantity + 1 }
					: cartItem
			);
		}
		*******************************************

	3. If existingCartItem is undefined (which means that there is no item found with the .find() function),
	then just return the current cart item with the "quantity" property with a value of "1" as a starting value of the first item.

		Sample Code:

		cart.reducer.js
		*******************************************
		...

		return [...cartItems, { ...cartItemToAdd, quantity: 1 }];
		*******************************************

	* Data comparison between grouped cart items and ungrouped cart items.

		Ungrouped items:
		----------------
			cartItems: Array(4)
				0: {id: 1, name: "Brown Brim", imageUrl: "https://i.ibb.co/ZYW3VTp/brown-brim.png", price: 25}
				1: {id: 1, name: "Brown Brim", imageUrl: "https://i.ibb.co/ZYW3VTp/brown-brim.png", price: 25}
				2: {id: 1, name: "Brown Brim", imageUrl: "https://i.ibb.co/ZYW3VTp/brown-brim.png", price: 25}
				3: {id: 1, name: "Brown Brim", imageUrl: ...}

		Grouped items:
		--------------
			cartItems: Array(1)
				0:  {id: 1,
					name: "Brown Brim",
					imageUrl: "https://i.ibb.co/ZYW3VTp/brown-brim.png",
					price: 25,
					quantity: 4}

-----------Selectors in Redux-------------

Scenario:
	Displaying the total number of items added to cart (total items) on the cart icon.

Solution: 
	Use the selector method .reduce() to pull off of the quantity from the cart items and add all quantity values of items into a single value (total quantity value).

	Notes:
		.reduce()
			- reduces the array to a single value.
			- The return value of the function is stored in an accumulator (result/total).
			- does not execute the function for array elements without values.
			- this method does not change the original array.

	Sample Code:

	cart-icon.component.jsx
	******************************************
	const CartIcon = ({ toggleCartHidden, itemCount }) => (
		<div className='cart-icon' onClick={toggleCartHidden}>
			<ShoppingIcon className='shopping-icon'/>
			<span className='item-count'>{itemCount}</span>
		</div>
	);

	const mapStateToProps = ({ cart: { cartItems } }) => ({
		itemCount: cartItems.reduce((acc, cartItem) =>
			acc + cartItem.quantity
		, 0)
	});

	export default connect(mapStateToProps, mapDispatchToProps)(CartIcon);
	******************************************

	Caveat:
		- Whenever any reducer updates, it returns a new object that will rerender the component.
		- Whenever the reducer returns a new object, redux recomposes and rebuilds the entire state object's "mapStateToProps" and is actually getting called every single time which is always passing in new props to our components.

		Note:
			reduce() is always returning a new value because it doesn't know that the cart items coming in might be the exact same (value) which is NOT good for performance because we don't want to rerender our component every time the state changes ESPECIALLY if those state changes don't actually modify the parts of the state that our component cares about.

	Caveat's Solution:
		- Store or cache the value of what our selector(reduce()) is using to compute it's value.
		- If the cart item values don't actually change right and if the output of the selector doesn't change, we don't want to rerender our component -- this is called "Memoization"

		Memoization
			- is the caching of the selectors value and can be achieved using a library called "Reselect".
			- other benefits of Reselect library is it separates the selectors and make them reusable.

---------Reselect Library--------

1. Install Reselect library with the command:  

	| npm install reselect

2. create a new file in a format like this:

	redux/cart/cart.selectors.js

	Note: 
		This selector is used related to cart.

3. Import "createSelector" from reselect.
	
	Sample Code:

	cart.selectors.js
	****************************************
	import { createSelector } from 'reselect';
	****************************************

	2 Types of Selectors:
		1. Input selector
			- doesn't use the "createSelector".
			- it is a function that gets the whole state and just returns a slice of it (e.g. pulling off the cart from the cartReducer).

			Sample Code:
			cart.selectors.js
			**********************************
			import { createSelector } from 'reselect';

			/*
				Selects the cart property from the rootReducer which will be used as an input for the Output selector.
			*/
			const selectCart = state => state.cart;
			**********************************

		2. Output selector
			- does use input selectors and "createSelector" to build themselves.
			- it is an instance of createSelector which accepts two arguments:
				Arguments:
					1: Collection of input selectors (in array).
					2: A function that will return the value we want out of the selector. 
					- What we're going to get in its parameters is actually each output of the input selectors in the array but in the order that those selectors were written. 
					- the created selector using "createSelector" is now called a "memoir selector".

			Sample Code:
			
			cart.selectors.js
			************************************
			import { createSelector } from 'reselect';

			...
			/*
				Selects the cart items and pulls cart items off out from the cart object and store it in to selectCartItems variable.
			*/
			export const selectCartItems = createSelector(
				[selectCart],
				cart => cart.cartItems
			);

			/*
				Get the reduce value of cart items which is the total quantity of all cart items.
			*/
			export const selectCartItemsCount = createSelector(
				[selectCartItems],
				cartItems =>
					cartItems.reduce(
						(acc, cartItem) =>
							acc + cartItem.quantity,
						0
					);
			);
			************************************			

4. Import the selector to the component that needs it. 

	Sample Code:
	cart-dropdown.component.jsx
	****************************************
	import { selectCartItems } from '../../redux/cart/cart.selectors';

	...

	/*
		Calling the selectCartItems selector and passing the whole state as an argument 
		and Passing the result to the cartItems property which holds all the items from the cart which will also be used as a prop of the component.
	*/
	const mapStateToProps = (state) => ({
		cartItems: selectCartItems(state)
	});
	****************************************

	Note:
		The state that is passed to the selector will be referenced to the input selector which will then select the cart from the state and passed it to output selector that needs it.


----------More on Selector------------

createStructuredSelector
	- imported from reselect library
	- passed the top level state that we get into each subsequent selector

	Sample Code:
	header.component.jsx
	*************************************
	import { createStructuredSelector } from 'reselect';

	...

	/*
		FROM:
	*/
	const mapStateToProps = state => ({
		currentUser: selectCurrentUser(state),
		hidden: selectCartHidden(state)
	});


	/*
		TO:
	*/
	const mapStateToProps = createStructuredSelector({
		currentUser: selectCurrentUser,
		hidden: selectCartHidden
	});
	*************************************

	Note:
		When you start using createStructuredSelector, use it to all components with mapStateToProps even if there is only one selector used in the component so it would be easy to add another selector since it is already setup.

--------Checkout Page------------

Six types of falsy values:
	1. 0
	2. false
	3. undefined
	4. null
	5. NaN
	6. ""

	Note:
		All this six types will evaluate to false.

Default values:
	For objects: null
	For numbers: zero
	For string: empty string

* You can check if an array has a value by getting the length of the array itself using .length.
	Example:
		array.length ? 
			"Array has value"
		:   "Array is empty";

Acquired Ideas:
	1. use "Link" component from 'react-router-dom' to route user to other pages with links like navigation links.

	2. use "withRouter" component from 'react-router-dom' to route user to other pages with buttons and anything that is not a link. Use the history.push() to push new route.

		Sample Code:

		*******************************************
		import { withRouter } from 'react-router-dom';

		const AnyFunction = (history) => (
			<button
				onClick={() => history.push('/checkout')}
			> 
			GO TO CHECKOUT 
			</button>
		);

		export default withRouter(connect()(AnyFunction))
		*******************************************

		Note:
			withRouter should be the outer higher-order component before connect();
			- The order between withRouter and connect matters.

-----------Dispatch Action Shorthand-------------

* If the mapDispatchToProps or NULL value is not passed as the second argument of connect(), redux is actually passing dispatch by default. In other words, you have the access to dispatch function in the App.

	Sample Code:
	*************************************************
	import { someReduxAction } from '../../redux/cart/cart.actions';

	const CartDropdown = ({ dispatch }) => (
		<div>
			<button
				onClick={() => {
					/*
						You can use dispatch without writing unnecessary mapDispatchToProps to use dispatch() to dispatch an action to the reducer.
					*/
					dispatch(someReduxAction())
				}}
			>
			Click Me
			</button>
		</div>
	);
	*************************************************

---------Remove Items from Cart-----------

* Remember that when you deep destructure the prop, you cannot access the properties of that prop.
	
	Sample Code:
	checkout-item.component.jsx
	****************************************************
	/*
		The cartItem has no access to its property because it has been destructured.
	*/
	const CheckoutItem = ({ cartItem: { name, quantity, price, imageUrl } }) => (

	);

	export default CheckoutItem;

	...

	/*
		The cartItem has access to its property with this method:
	*/
	const CheckoutItem = ({ cartItem }) => (

		const { name, quantity, price, imageUrl } = cartItem;
		
		return (
			...
		)
	);

	export default CheckoutItem;
	****************************************************
*******************************************************

CHAPTER #9: Master Project Session Storage + Persistence

--------Local Storage and Session Storage----------

Local Storage:
	- will persist until it is cleared out.
	- If the browser window or the browser itself is close, whatever that is stored in the local storage is still accessible.

		Two functions:
			1. setItem()
				- set the item to be stored into the local storage object.

				takes Two parameters:
					1. Key
						- a string value
						- will be referenced later to fetch the value attached to it.

					2. Value
						- a string value.
						- use JSON.stringify to convert JavaScript object to JSON object.

			2. getItem()
				- get the item from the local storage.
				- takes the Key as a parameter to retrieve the specific stored value.
				- use JSON.parse() to convert JSON object to JavaScript object.

	Example:
		- Add item to the local storage:
			localStorage.setItem('myCat', 'Tom');

		- The syntax for reading the localStorage item is as follows:
			var cat = localStorage.getItem('myCat');

		- The syntax for removing the localStorage item is as follows:
			localStorage.removeItem('myCat');

		- The syntax for removing all the localStorage items is as follows:
			// Clear all items
			localStorage.clear();

Session Storage:
	- persists throughout the session. As long as the tab is open even if we refresh the page, the app still has access to what has been stored in session storage.
	- If the page is closed, then whatever that is stored in session storage will be lost.

	Syntax:
		/* Save data to sessionStorage */
		sessionStorage.setItem('key', 'value');

		/* Get saved data from sessionStorage */
		let data = sessionStorage.getItem('key');

		/* Remove saved data from sessionStorage */
		sessionStorage.removeItem('key');

		/* Remove all saved data from sessionStorage */
		sessionStorage.clear();

----------Redux Persist------------
Redux Persist:
	- let us leverage either local storage or session storage.

Using Redux Persist:

	1. Install redux-persist library on the app using the command:
	|	npm install redux-persist

	2. Go to store.js file and import "persistStore" from redux-persist library and do some config:

		Sample Code:

		store.js
		***************************************
		import { persistStore } from 'redux-persist';

		const store = createStore(rootReducer, applyMiddleware(...middleware));

		/* Persisted version of store */
		export const persistor = persistStore(store);

		export default {store, persistor};
		***************************************
		Note:
			What persistStore does is it allows the browser to actually cache our store depending on certain configuration option.

	3. Go to root-reducer.js and do the following:
		1. import the "persistReducer" from redux-persist
		2. import "storage" from redux-persist/lib/storage
		3. define the persist configuration that will going to be used.

		Sample Code:

		root-reducer.js
		*****************************************
		import { persistReducer } from 'redux-persist';
		import storage from 'redux-persist/lib/storage';

		/* redux-persist configuration that will be used */
		const persistConfig = {
			key: 'root',
			storage,
			whitelist: ['cart']
		}

		const rootReducer = combineReducers({
			user: userReducer,
			cart: cartReducer
		});

		export default persistReducer(persistConfig, rootReducer);
		*****************************************
		Note:
			- "storage" property is the type of storage that will be used.
			- "whitelist" property is an array containing the string names of any of the reducer that we want to store.
			- the "persistReducer()" is a function that takes two arguments:
				1. persist configuration
				2. rootReducer (the reducers that are combined with combineReducers())
			- this modify the root reducer with the persistence capabilities.

	4. Go to index.js and do the following:
		1. import "PersistGate" from redux-persist/integration/react.
		2. import the "store" and the "persistor" from store.js
		3. Wrap the App component inside the PersistGate component.
		4. Pass the "persistor" as a prop to the PersistGate component.

		Sample Code:

		index.js
		**************************************
		import { PersistGate } from 'redux-persist/integration/react';

		import { store, persistor } from './redux/store';

		ReactDOM.render(
			<Provider store={store}>
				<BrowserRouter>
					/*
						The App is wrap inside the PersistGate with the persistor as the passed prop
					*/
					<PersistGate persistor={persistor}>
						<App />
					</PersistGate>
				</BrowserRouter>
			</Provider>, 
			document.getElementById('root'));
		**************************************
		Note:
			- We wrap the App in the PersistGate because what we want to do is to have the application always have access to the persistence flow itself.
			- What will do is it will allow the PersistGate to actually the one receive the store but also fire off actions that will rehydrate the state whenever our application refreshes. 
*****************************************************

CHAPTER #10: Master Project Redux 2

------------More on State-------------

* Remember that it is a good practice to store local state that will never going to be updated into redux for the Testing purposes when testing the application.

* - What you usually do with this is to make a new reducer. 
  - Set the default state as the INITIAL_STATE which will be the default state of the "state" parameter of the reducer.
  - In the switch statement block, just return this state in the default case block.

******************************************************

CHAPTER #11: Master Project Advanced Routing

---------- Nested Routing----------

Scenario:
	Nesting Route from component to another component with a reference of the current path.

Solution: 
	- Use the "match" object to access the current path of that we are matching.
	- Use string interpolation to add a new string to the path (e.g. route parameter).

-----------More on Routing----------

mapStateToProps has a second argument which is the owned Props of the component.

******************************************************************************

CHAPTER #12: Master Project State Normalization

----------Data Normalization----------

Data Normalization
	- storing lists of items in objects instead of arrays.

	When to use this:
		When you need an individual element inside of these arrays.

	Sample Code:

	shop.selectors.js
	***************************************
	/* FROM */
	const COLLECTION_ID_MAP = {
		hats: 1,
		sneakers: 2,
		jackets: 3,
		womens: 4,
		mens: 5
	};

	export const selectCollection = collectionUrlParam => 
		createSelector(
			[selectCollections],
			collections => 
				/* .find() is good for small items in an array but reduced performance with large elements because it loops through the whole list until it finds the exact item which will then waste time.*/

				collections.find(
					collection =>
						collection.id === COLLECTION_ID_MAP[collectionUrlParam]
				)
		);

	/* TO */
	***************************************
	export const selectCollection = collectionUrlParam => 
		createSelector(
			[selectCollections],
			collections => 
				collections[collectionUrlParam]
		);
	***************************************

--------Data Flow In the App------------

Scenario:
	Displaying list of items from an object on the app.

	Example:
		const collections = {
			hats: {
				item_name: 'Boony',
				price: 24,
				...
			},
			jeans: {
				...
			},
			...
		}

Solution:
	If it is a list of items in array, we can use map to map over each item but it is an object so use Object.keys() instead.

	Object.keys([object]) 
		- returned the keys (i.e. hats and jeans and other keys) from the object in an array format).

	Chain the .map() function to access each item in an object through there respective keys.

	Example Code:

	shop.selectors.js
	********************************************
	export const selectCollectionsForPreview = createSelector(
		[selectCollections],
		collections =>
			Object.keys(collections).map(key => collections[key])
	);
	********************************************
	Note:
		We want to get all the keys and map over that array of keys so we get the value of our collections object at that key which will give us an array of items that we're trying to get.

********************************************

CHAPTER #13. Master Project Stripe Payments Part 1

----------Stripe Integration--------------

Stripe - an API that handles online payments.

1. Install stripe with the command:
|	npm install react-stripe-checkout

	- it gives the react bound version of the checkout button that stripe provides that opens up that component that we saw what we want.
2. Create a new component named "stipe-button" 
3. Import StripeCheckout component from 'react-stripe-checkout';

	Sample Code:

	stipe-button.component.jsx
	********************************************
	import StripeCheckout from 'react-stripe-checkout';
	********************************************
4. Do the following code to define the component:

	stipe-button.component.jsx
	********************************************
	import StripeCheckout from 'react-stripe-checkout';

	const StripeCheckoutButton = ({ price }) => {

		/*Converts price in dollar to cents*/
		const priceForStripe = price * 100

		const publishableKey = '[your stripe publishable key]'

		onToken = token => {
			console.log(token);
			alert('Payment Successful');

			/*With the token you would pass this to your back-end which then creates the charge. You can use fetch() for this*/
		};

		/*Returns the StripeCheckout Component*/
		return(
			<StripeCheckout
				label='Pay Now'
				name='CRWN Clothing Ltd.'
				billingAddress
				shippingAddress
				image='https://svgshare.com/i/CUz.svg'
				description={`Your total is $${price}`}
				amount={priceForStripe}
				panelLabel = 'Pay Now'
				token={onToken}
				stripeKey={publishableKey}
			/>
		)
	}

	export default StripeCheckoutButton;
	********************************************
	Notes:
		StripeCheckout Component takes a bunch of different possible properties that enable or disable different features that we have access to inside of the CheckoutDropdown component.
			- to check all the properties, go to the stripe github repo.

5. Import the newly created Component to the component that needs it:

	Sample Code:

	checkout.component.jsx
	*****************************************
	import StripeCheckoutButton from '../../components/stripe-button/stripe-button.component';

	const CheckoutPage = ({ cartItems, total }) => (	
		<div className='checkout-page'>

			...

			<StripeCheckoutButton price={total} />
		</div>
	);

	export default CheckoutPage;
	*****************************************

----------Finishing Touch the Project----------

Changing the Favicon and the Title of the Tab:

1. Go to index.html under the public folder.
2. Change the title there with the App's.
3. Replace the favicon under public folder.

*******************************************

CHAPTER #14. Master Project Deploying To Production

----------Deploying to Heroku------------
(Assuming that you already created a Heroku account)
1. Login to heroku with the command:
|	heroku login

2. Create a new Heroku project (static website) with the command:
|	heroku create [name_of_the_project] --buildpack
https://github/mars/create-react-app-build pack.git

	Note:
		--buildpack allows to deploy react project as a static website and we want this because it's the best and most efficient.

3. Push the project to heroku with the command:
|	git push heroku master

-----------Firebase Login Issue-----------

Scenario:
	Uncaught error "auth/unauthorized-domain" when logging in using firebase.

Solution:
	1. Go to firebase console.
	2. Go to Authentication
	3. Click on Sign-in method tab
	4. Add a new authorized domain (which is the domain of the app hosted by heroku).


---------Removing redux-logger from Production Build--------

1. Go to store.js

2. Remove logger from middlewares variable.

3. Under the middlwares variable do the following code:

	Code:

	store.js
	***************************************
	const middlewares = [];

	/*This will push logger middlware to middlewares variable if the current node environment is in development build.*/

	if(process.env.NODE_ENV === 'development') {
		middlewares.push(logger);
	}
	***************************************
	Note:
		This will remove the redux-logger logging into the console every time an action gets dispatch when in production mode.

*********************************************

CHAPTER #15. Master Project CSS in JS - styled-components

------------CSS in JS--------------

Current Way of using CSS in the Application:
	- The current way that we add CSS in the application is we import them into our component files and we try to namespace our CSS to the top level components classes or any of the children's classes but we scope them as best as we can with the CSS that we write.


Scenario:
	When the former developer create a Card Component with it's own styles. Years had passed a new hired developer created a new Component in the App and inside it's components he has his own card which uses the same class name as the card created by the former dev in the past years.

	Problem:
		Unexpected results will happen to the styles of the newly created Card of the new dev because he uses the same class name with the exisiting card class name.

	Reason:
		- CSS all share one single global namespace the moment that we import this CSS into our Card component and this component is rendered.

		JavaScript put this styling into the 
		head (i.e. <head></head>) of our applicaiton so we can actually see this when we look inside of our elements.

		This happens when we import styles into our components.

	Probable Solution 1:
		BEM (Block Element Modifier) 
			- is is a naming of your CSS so that you follow a certain format known as the Block, the Element, and then the Modifier.

		Example:
		********************************
			<div class="block">
				...
				<span class="block__elem">
				</span>
			</div>
		********************************
		Note:
			What ends up happening is you have these really really nested and really long class names on all of your components.

			-This adds extra mental overhead which is always a bad thing.

			This is the default problem with CSS as mentioned. BEM is a solution that was created based on the way that CSS was built.


	Probable Solution 2:
		We created an object of styles with its property in a cobabCase and pass this object to the style prop.

		Example Code:

		************************************
		const textStyles = {
			color: 'red',
			fontSize: '24'
		};

		function App() {
			return(
				<Card>
					<div style={textStyles}> Hello World! </div>
				</Card>
			)
		}
		************************************
		Notes:
			-What happens then is the style is directy written into the element.

		Issues:
			- We don't have access to all of the CSS selectors when we want specific selectors that we want to leverage that we can't such as "disabled" selector or cannot access "child" and so on.

	Best Solution:
		CSS in JS with "styled-components" library.

		Cons of using CSS in JS:
			- it is using a javascript library to render our styles very similar in the Solution 2.
			- the difference is the way that this was handled that it got placed on our div but what's still happening is that we're letting our javascript add our styles to our HTML.

		Pros:
			- Performance is extremely fast. JavaScript render the CSS is minimal practically non-existent on performance.
			- the CSS is scoped purely to that component.

		Notes:
			- What CSS in Js aims to solve by using JavaScript to render our CSS is to encapsulate all of our CSS to just the component that is relevant.


---------styled-components-----------

1. Install styled-components library with the command:

|	npm install styled-components

2. Go to App.js and import styled keyword.

	Example:
	******************************************
	import styled from 'styled-components';
	******************************************
	Note:
		This keyword allows to actually generate components.

	2.1. Create a new component with it's own style with styled keyword.

		Example Code:

		*******************************************
		const Text = styled.div`
			color: red;
			font-size: 28px;
			border: ${({ isActive }) => 
				isActive ? '1px solid black': '3px dotted green'};
		`

		function App() {
			return (
				<div className='App'>
					<Card>
						<Text isActive={false}> I am a component </Text>
					</Card>
				</div>
			)
		}
		******************************************
		Note:
			- styled keyword generates a new component with it's specified element and it gives this component's element with a unique string class so as a result, the styles will never bleed across the application.
			- it then create a new stylesheet with those unique styles pointing to this unique class name.

			- we can pass a prop to this generated components the same as how we pass props to other React components.


-----------styled-components In the App----------

* When using styled components, create a separate file for that component in a format like this:

	card/card.styles.jsx


* The common syntax for styled components is like this:
	
	Syntax:

	************************************************
	export StyledComponentName = styled.element`
		... [your styles]
	`;
	************************************************


* If you want to make a styled Link (react-router-dom component), just pass the Link component as an argument for "styled" keyword.

	Example Code: 

	header.styles.jsx
	**********************************************
	import styled from 'styled-components';
	import { Link } from 'react-router-dom';

	export const LogoContainer = styled(Link)`
		height: 100%;
	    width: 70px;
	    padding: 25px;
	`;
	**********************************************


* If you want to apply style to more that two styled components, import css from 'styled-components' and place it instead of "styled" keyword and passed the variable to those styled components inside a string interpolation.

	Example Code: 

	header.styles.jsx
	**********************************************
	import styled, { css } from 'styled-components';
	import { Link } from 'react-router-dom';

	const OptionContainerStyles = css`
		padding: 10px 15px;
	    cursor: pointer;
	`;

	/**/
	export const OptionLink = styled(Link)`
		${OptionContainerStyles}
	`;

	export const OptionDiv = styled.div`
		${OptionContainerStyles}
	`;
	**********************************************
	Note:
		"css" enables to reuse the styles by styled components.

		- import this styled components to the React Component.

-----------More on styled-components------------

Scenario:
	The custom button component changes styles depending on a condition which makes the button element getting messy with ternary operator which set what class should be applied depending on the condition.

	Example: 

	<button className={`
		${inverted ? 'inverted': ''} ${isGoogleSignIn? 'google-sign-in': ''} custom-button`} 
		{...otherProps}
	> 
		{children}
	</button>

Solution:
	1. Convert this button element into styled component.

	2. Define your button styled component first.

	3. Create styles for each of your styles (i.e. inverted button, isGoogleSignIn button, the regular button styles) with "css" keyword.
	
	4. Define a function that will accept the props passed by the parent Component which will then check the props properties if it needs inverted button style or googleSignIn button style or the regular button style if the rest of the condition is false.

	Example Code:

	custom-button.styles.jsx
	****************************************

	/*Styles for a regular button*/
	const buttonStyles = css`
		background-color: black;
		color: white;
		border: none;
		
		&:hover {
			background-color: white;
			color: black;
			border: 1px solid black;
		}
	`;

	/*Styles for an inverted button*/
	const invertedButtonStyles = css`
		...
	`;

	/*Styles for a googleSignIn button*/
	const googleSignInButtonStyles = css`
		...
	`;

	/*A function which accepts the props that is passed and check what button styles is needed based on condition and return the button styles that satisfy the condition*/

	const getButtonStyles = props => {
		if(props.isGoogleSignIn) {
			return googleSignInButtonStyles;
		}

		return props.inverted ? invertedButtonStyles : buttonStyles; 
	}

	/*Defining the CustomButtonContainer styled component and setting it's styles for layouting purposes and calling the function which will give the desired button style inside the string interpolation*/

	export const CustomButtonContainer = styled.button`
		min-width: 165px;
		width: auto;
		height: 50px;
		letter-spacing: 0.5px;
		line-height: 50px;
		padding: 0 35px 0 35px;
		font-size: 15px;
		text-transform: uppercase;
		font-family: 'Open Sans Condensed';
		font-weight: bolder;
		cursor: pointer;
		display: flex;
		justify-content: center;

		${getButtonStyles}
	`;
	****************************************

************************************************

CHAPTER #16. Master Project Advanced Redux + Firebase

-----------Moving the Shop Data to Firebase----------

* Keep in mind that when we're using a no sequel database, we have to make sure that we enforce ourselves to store the same values across our documents if we can because we don't want to pull in all of our documents and iterate throught them only to find that some objects don't have properties that we expect them to have beyond that.

* When you want to add a new collection and document to firestore to add the existing data that is hard coded so it wouldn't be a pain to write it on the firestore explicitly, add a new function which accepts the collection key and the document to be added as arguments that will be used to store to the firestore as new collection with it's documents.

	Example Code:

	firebase.utils.js
	*******************************************
	export const addCollectionAndDocuments = (collectionKey, documentsToAdd) => {
		const collectionRef = firestore.collection(collectionKey);
		console.log(collectionRef);
	};
	*******************************************
	Note: 
		- Before adding the whole code to store the new collection and it's respective document, it is a good idea to check the function first if it is working.
		- Import this function to App.js and just call it inside the componentDidMount() class method and check the console after the browser refreshes to see if the collection reference object is displayed.
		- All these code will be removed afterwards because its purpose is to store only the starting collections and documents on the database.

* Caveat about Firestore:
	- The thing about firestore is that we can only make one set (creating document) at a time. We can't call collectionRef.set() and then set an array of values in as the collection's documents. In other words, each call is individual and fire one at a time.

	Scenario:
		If our internet connection stops halfway through, our code only will have saved half of those documents because the other half would not have made it to the server. This is bad because the code is unpredictable and we want to know that if we hit our function and all of our requests send -- all of them should set. If any of them fail, then we want the whole thing to fail because we can anticipate it that we know that the code is consistent.

	Solution:
		-Use firestore batch object. With this batch object, we just add all of our sets into it and then we fired off whenever we're done adding all the calls we want to it. 

		- Then we will loop over this objects to add array using the foreach() method.

		Example Code:

		firebase.utils.js
		****************************************
		export const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {
			const collectionRef = firestore.collection(collectionKey);
			
			/*Instantiate the firestore's batch object to set the whole objects in one set*/
			const batch = firestore.batch();

			/*Looping through the objects and set each object (document to be added to firestore) its own id with batch.set()*/

			objectsToAdd.forEach(obj => {
				const newDocRef = collectionRef.doc();
				batch.set(newDocRef, obj);
			});

			/*	.commit() will fire off batch request
				It returns a promise. When commit succeeds, it will come back and resolve a void value (null value) which can be used to handle error when we call addCollectionAndDocuments function and chain .then()
			*/
			return await batch.commit();
		};
		****************************************
		
------------Bringing Shop Data to the App----------

1. Pull the firestore data in the nearest component ancestor so both the children components that need it can access the data without repeating writing code for each children component (DRY [Do Not Repeat Yourself] concept).

	Example Code:

	shop.components.jsx
	*************************************************
	unsubscribeFromSnapshot = null;

	componentDidMount() {
		const collectionRef = firestore.collection('collections');

		/*onSnapshot will listen if the collectionRef changes which will pass the snapshot of the new collectionRef*/

		collectionRef.onSnapshot( async snapshot => 
			convertCollectionSnapshotToMap(snapshot);
		);

	}
	*************************************************

Scenario:
	The data from firestore don't have the properties that is required for the components to run like: routeName (because this is not necessary to store into the database as it is only used in the frontend for web and which can also be a waste of memory. Assuming that the data in firestore is also used in mobile app which doesn't really need the routeName).

Solution:
	1. Create a function which will accept the querySnapshot as parameter.

	2. This function will map through each docs that come from querySnapshot.

	3. Destructure the properties from each docs with .data().

	4. Return a new object with the "routeName" property and it's value

		4.1. To set a value for the routeName, use the title property and convert it to lowercase using .toLowerCase() [because the title is in sentence case] and passed it inside encodeURI().
		Coincidently, the "routeName" property value has the same value as the "title" property value (but in Sentence case while the former is all lowercase).

		encodeURI()
			- accepts string and will give back a string where any characters that the url cannot actually handle or process such as certain symbols, spaces, or whatever that you actually never see in a url.
			- it will make sure to convert them into a version that the url can actually read.

		Note:
			- encodeURI() is used because the routeName is a thing that is used in order to route by URL.

	Sample Code:

	firebase.utils.js
	**************************************************
	export const convertCollectionSnapshotToMap = collections => {
		const transformedCollections = collections.docs.map(doc => {

			/*Destructure properties off from doc object*/
			const { title, items } = doc.data();

			/*Return a new object with routeName as the new added property and the id which is the id created by firestore*/
			return {
				routeName: encodeURI(title.toLowerCase()),
				id: doc.id,
				title,
				items
			}
		});
	}
	/*Display the new collections with the routeName property*/
	console.log(transformedCollections);
	**************************************************

------------Adding Shop Data to Redux----------

Scenario:
	Adding the transformed collections from firestore to redux store.

Solution:
	1. Create a file shop.actions.js and define your function there with a parameter which will accept the mapped collections.

	Sample Code:

	shop.actions.js
	***************************************
	export const updateCollections = collectionsMap => ({
		type: ShopActionTypes.UPDATE_COLLECTIONS,
		payload: collectionsMap
	});
	***************************************

	2. Go to the shop.reducer.js and import the action and add a new case for this action.

	3. Go to the shop.component.jsx and import the action and connect() to enable to dispatch the action to the reducer.

	4. Destructure the newly created prop that handles in dispatching the actions to the reducer which will update the collections and make changes to the DOM.

***********************************************************

CHAPTER #17. Master Project HOC Patterns

------------WithSpinner HOC-----------

Scenario:
	When the data that the component needs is still on the process (e.g. pending firestore data), if not handled, it will give an error in the app that some props is null.

Solution:
	Create a loading message or any loading symbols that will inform user that the page is still on the process.

	Steps:
		1. Create a higher order component called "with-spinner".

			Sample Code:

			with-spinner.component.jsx
			**************************************************
			import { SpinnerOverlay, SpinnerContainer } from './with-spinner.styles';

			const WithSpinner = WrappedComponent => ({isLoading, ...otherProps}) => {
				return isLoading ? (
					// component that will ensure that this component will be at the center of the page
					<SpinnerOverlay>

						// the spinner
						<SpinnerContainer />
					</SpinnerOverlay>
				) : (
					<WrappedComponent {...otherProps}/>
				)
			};

			export default WithSpinner;
			**************************************************
			Notes:
				- When "isLoading" is true which means that the page data is still on the process of fetching it from firestore, it will display the spinner.
				- If it is false, then it will display the page with the fetched data.

		2. Go to the component (Shop Component for instance) that receives and makes the call to update the reducer after getting the data back from the backend. For this reason we have to put the logic for determining the "with-spinner" on our "shop" component.

		The logic is going to be contained within the Shop page because the shop page is actually the one that knows when technically speaking our shop data is finished loading because the moment that snapshot comes back and it's converted (to array of objects since it is in the form of [object Object] and the component that going to use it use an array of objects) we update the reducer. At that point we know that technically speaking, our shop page is good to render the collection object.

		3. Import the higher order component "with-spinner" in the "shop" component.

		4. Passed the component(s) to the WithSpinner HOC as argument that needs the spinner and store the returned value in a new variable that will be the new name of the processed component from WithSpinner.

			Sample Code:

			shop.component.jsx
			*********************************************
			/*The WithSpinner higher-order component will return Spinner component if the "loading" state is true, else, it will return the wrapped component with it's props to a newly defined component (e.g. CollectionsOverviewWithSpinner)*/

			const CollectionsOverviewWithSpinner = WithSpinner(CollectionsOverview);
			const CollectionPageWithSpinner = WithSpinner(CollectionPage);
			*********************************************

		5. Call this.state and set the loading property to true as the default value for the isLoading property that is going to be passed to those new processed components (by the WithSpinner).

			Sample Code:

			shop.component.jsx
			**********************************************
			/*More simplified way to call a state without calling constructor() and super()*/
			state = {
				loading: true
			}
			**********************************************

		6. Set the state to false after we call the action that will update the reducer which change the collections object.

			Sample Code:

			shop.component.jsx
			**********************************************
			componentDidMount() {

				...

				collectionsRef.onSnapshot(async snapshot => {
					const collectionsMap = convertCollectionsSnapshotToMap(snapshot);

					/*The action that will update the shopReducer*/
					updateCollections(collectionsMap);

					/*If the reducer has been updated after dispatching the update collection action, set the "isLoading" to false*/
					this.setState({loading: false});
				});
			}
			**********************************************

		7. In the Routes component declaration, instead of using the "component" property to send what component to render when routed by url, use the "render" property instead which rerenders component when changes has been made to the new component.

		Pass the props from the Route component explicitly to the rendered component since an anonymous function is defined which create its own scope that doesn't have any connection to the class scope.

			Sample Code:

			shop.component.jsx
			**********************************************
			render() {
				const { match } = this.props;
				const { isLoading } = this.state;
				return( 
					<div className='shop-page'>
						<Route exact
							path={`${match.path}`}

							/*Passing the props (match, location, history) to the component that will be (re)rendered*/

							render={(props) => 
								(<CollectionsOverviewWithSpinner isLoading={isLoading} {...props} />)
							} 
						/>
						<Route 
							path={`${match.path}/:collectionId`} 
							render={(props) => 
							  	(<CollectionPageWithSpinner isLoading={isLoading} {...props}/>)
							}  
						/>
					</div>
				);
			};
			**********************************************
			Notes:
				The render() is a method that takes a function where the parameters and the function are pretty much just the parameters that the component will receive, which in this case are going to be the: match, location, and history props that the Route passes into the component which is what gives the collection page access to the match object that is use inside the selector -- which is pull off of "ownProps" (see collection.component.jsx) 

Conclusion:
	When we run the application in the browser and go to the shop page (also collection page), we will see the spinner that loads while our component is fetching the backend data. The moment it comes back and updates the reducer it flips the loading to false which then renders our actual final component.

----------How to Build HOC's-------------

Higher-Order Component:
	- Is a component
	- Takes in a component as an argument
	- Returns a new component
	- The component it returns can render the original component that was passed in

	Sample Code:

	Steps:
		1. Take in a “WrappedComponent” argument.

			Sample Code:

			************************************
			function hocComponent (WrappedComponent) {

			}
			************************************

		2. Return a new component

			Sample Code:

			************************************
			function hocComponent (WrappedComponent) {
				return class HocComponent extends React.Component {

				}
			}
			************************************

		3. Render the “WrappedComponent” argument passing it a prop.

			Sample Code:

			************************************
			function hocComponent (WrappedComponent) {
				return class HocComponent extends React.Component {
					state = { someProp: false }
				    mouseOver = () => this.setState({ someProp: true })
				    mouseOut = () => this.setState({ someProp: false })
				    render() {
						return (
							<div onMouseOver={this.mouseOver} onMouseOut={this.mouseOut}>
							  <WrappedComponent someProp={this.state.someProp} />
							</div>
						);
				    }
				}
			}
			************************************

****************************************************

CHAPTER #18. Master Project Asynchronous Redux

---------Observables + Observer Pattern----------

Observer
	- is some piece of code that wraps the stream of events.
	- is a piece of code that essentially has three function calls on it.

	Three function calls:

		next: (nextValue) => { 
			//Do something with value
		},

		error: (error) => { 
			//Do something with error
		},

		complete: () => {
		 	//Do something when finished
		}


Observable Pattern Diagram:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

							Observable (Stream of Events):

           -----> Event -----> Event -----> Event ----> Event -----> Event ------>
										^
										|
										|
									Subscription
										|	
										|
										|

									Observer:						
					{
						next: (nextValue) => { 
							//Do something with value
						},

						error: (error) => { 
							//Do something with error
						},

						complete: () => {
						 	//Do something when finished
						 	//optional
						}
					}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

					Notes:
						- Observer has:
							1. "next" call 
									- which is literally just the code that you execute whenever a new event happens.

							2. "error" call
									- is something that we do when an error occurs.

							3. "complete" call
									- is an optional call that will occur if for example the stream is finished. 
									(A stream can definitely stop emitting data.

										For example:
											We know that from our back end let's say we were giving five pieces of data in an unknown amount of time. After we've gotten all five, we know that we don't need any more data so we can actually stop listening and shut down this stream because we don't need to keep it open anymore.

											The observable is capable of stopping the stream at some point and if we have any of these observers then they're complete calls get called and how this happens is through what's called "Subscription".

											Subscription
												- is essentially a way for us to tie our Observer using what's called a "listener".

													- the observer is listening to these values (from stream of events [observable]) and we're subscribing to this observer's stream of events.

													-  What Observer does is we are saying for example:
													"Hey! Observable I'm gonna give you my function calls. Whenever new event comes in, I want you to call the 'next' on it. Whenever an error comes in, I want you to call 'error'.  When it completes, I want you to call the 'complete' ."
									)

									- the complete call is rarely happen in Firebase because it is a live database which means that updates can always happen.

						- an Observable is a stream which means that there are subsequent concurrent back to back events that could occur in an asynchronous fashion (e.g. user clicking multiple times).
							- it is some piece of code that wraps around this stream so that we're actually able to do something with the value of that piece of data at each event.

						- an Observable can have many listeners

						- the subscription never ends because the stream is always open. If we instantiated some listener, this listener exists now because it's always listening for events.

						If our component unmounts, we don't care about this listener as far as this component is concerned anymore but because the auth stream is always exists inside of the auth library which is in our application now.

						Once we imported it, then it's going to always hold on to this listener.

						What we have to do is we have to unsubscribe from it.

						Firestore allows to get back and unsubscribe function that the moment we call it, it will eliminate that listener so you can kind of see it as whenever the auth.onAuthStateChanged() get's instantiated, it gives us back some reference -- that's a function that can get called that points to this listener (onAuthStateChanged()) that we just instantiated right inside the "componenetWillUnmount()" lifecycle method

						Example Code:

						***************************
						componentWillUnmount() {
							this.unsubscribeFromAuth();
						}
						***************************

						- the moment the component unmounts, we unsubscribe from it.


---------Redux Thunk-----------

- handles asynchronous actions.

1. Install Redux Thunk with the command:

|	npm install redux-thunk

	Notes:
		Redux Thunk
			- is a middleware that allows us to fire actions.

2. Go to store.js and import thunk from 'redux-thunk' and put "thunk" in the "middlewares" array.

... break

Scenario:
	From ShopPage component, we want to put the code that fetches the data from firebase to a place where for example enable other components (might be) to leverage the same functionality, it can reuse it without rewriting the code. 

Solution:
	We use a library that handles asynchronous actions (Redux Thunk) and create an actions to handle this problem:

	Steps:
		...continuation

		3. Go to shop.types.js and add the following action types:

			FETCH_COLLECTIONS_START: 'FETCH_COLLECTIONS_START'
				- tells redux we're starting to fetch the data. This is before any data get fetch. This is when the first API call to our firestore begins.

			FETCH_COLLECTIONS_SUCCESS
				- when fetching of data is successful this is where it comes back from us with a successful API request and hopefully the data that we need is also come back as well.

			FETCH_COLLECTIONS_FAILURE
				- this is pretty much what happens if for example the server is down or the internet connection is poor. This handles this kind of error with it's own function.

			Sample Code:

				shop.types.js
				******************************************
				export const ShopActionTypes = {
					FETCH_COLLECTIONS_START: 'FETCH_COLLECTIONS_START',
					FETCH_COLLECTIONS_SUCCESS: 'FETCH_COLLECTIONS_SUCCESS',
					FETCH_COLLECTIONS_FAILURE: 'FETCH_COLLECTIONS_FAILURE'
				};
				******************************************

		4. Go to shop.reducer.js and add "isFetching: false" property to the initial state object because the reducer needs to be aware whether data is being fetched or successfully fetched. Also, add the "errorMessage" property to store the error message if the request failed.

		Sample Code:

			shop.reducer.js
			************************************
			const INITIAL_STATE = {
				collections: null,
				isFetching: false,
				errorMessage: action.payload
			};
			************************************

			- all this initial state is indicating that there is a state where our application is fetching data related to the shop reducer.

		5. Add the new cases for the new types in the reducer function.

		Sample Code:

			shop.reducer.js
			************************************
			const shopReducer = (state = INITIAL_STATE, action) => {
				switch(action.type) {
					case ShopActionTypes.FETCH_COLLECTIONS_START:
						return {
							...state,
							isFetching: true
						}
					case ShopActionTypes.FETCH_COLLECTIONS_SUCCESS:
						return {
							...state,
							isFetching: false,
							collections: action.payload
						}
					case ShopActionTypes.FETCH_COLLECTIONS_FAILURE:
						return {
							...state,
							isFetching: false,
							errorMessage: action.payload
						}
					default:
						return state;
				}
			}
			************************************
			Explanation:
				- When the action that is currently fired is FETCH_COLLECTIONS_START, it returned the "isFetching" with a value of true because the data is currently on fetching process.

				"isFetching: false" for FETCH_COLLECTIONS_SUCCESS because the data is already fetched, 

				and "isFetching: false" and "errorMessage: action.payload" is for FETCH_COLLECTIONS_FAILURE if there is any error in fetching the data from firestore.


		6. Go to shop.actions.js. This is where we leverage thunk.

			Thunk
				- is an action creator that returns a function that gets the dispatch very similar to the mapDispatchToProps instead of creating an action that returns an action (action === javascript object)

				- we're going to write a function that returns a function that gets dispatch in it so that whenever dispatch is called, it will fire multiple actions.

			6.1. Create the action for FETCH_COLLECTIONS_START without payload as it is only going to just set the isFetching to true.

				Sample Code:
					************************************************
					export const fetchCollectionsStart = () => ({
						type: ShopActionTypes.FETCH_COLLECTIONS_START
					});
					************************************************


			6.2. Create the thunk function that will dispatch these actions (fetchCollectionsStart, etc.) inside of it.

				Sample Code:
					************************************************

					...

					/********The "thunk" function*********/
					export const fetchCollectionsStartAsync = () => {

						return dispatch => {

							/********Creating the collections reference*********/
							const collectionsRef = firestore.collection('collections');

							/********Dispatching the function that will update the reducer's state "isFetching" to true...*********/
							dispatch(fetchCollectionsStart());

							/********...Beginning of asynchronous request*********/
							collectionsRef
								.get()
								.then(snapshot => {
									const collectionsMap = convertCollectionsSnapshotToMap(snapshot);

									/*********Dispatching the function that will update the reducer with payload***********/
									dispatch(fetchCollectionsSuccess(collectionsMap));
								})
								.catch(error => 
									/*********Dispatching the function that will handle any API request error**********/
									dispatch(fetchCollectionsFailure(error.message));
								);

							/********If redux-thunk middleware is enabled, any time you attempt to dispatch a function instead of an object, the middleware will call that function with dispatch method itself as the first argument
							
							This is all "thunk" is. It's just a function that returns a function that gets access to dispatch so that we can dispatch multiple actions and handle asynchronous code inside of it. 
							*********/
						}
					}
					************************************************

			7. Import the "thunk" method (created in the shop.actions.js) in shop.component.jsx

			8. Import the createStructuredSelector from Reselect library because we want to select certain values off of our state.

			8.1. Also, import connect from 'react-redux' because we want to pull state from redux.

			9. Create the selector that will pull in the "isFetching" property.

			Sample Code:

				shop.selectors.js
				***************************************
				export const selectIsCollectionsFetching = createSelector(
					[selectShop],
					shop => shop.isFetching
				);
				***************************************

			10. Import the selector in shop.component.jsx

			11. Write the mapStateToProps

				Sample Code:

					shop.component.jsx
					******************************
					const mapStateToProps = createStructuredSelector({
						isCollectionsFetching: selectIsCollectionsFetching
					});

			12. In mapDispatchToProps, we now need the "thunk" method from our action so import this function and do the following:

				Sample Code:

				shop.component.jsx
				***************************************
				const mapDispatchToProps = dispatch => ({
					fetchCollectionsStartAsync: () => dispatch(fetchCollectionsStartAsync())
				});
				***************************************

			13. Instead of pulling the old "loading" property from the old async request, destructure the "isCollectionsFetching" from props and set it as the prop value of "isLoading" property.

			14. Destructure the method that will dispatch the "thunk" method inside the componentDidMount() lifecycle method.

				Sample Code:

				shop.component.jsx
				***************************************
				componentDidMount() {
					const { fetchCollectionsStartAsync } = this.props;

					/*Call the destructured prop function the moment the component mounts*/

					fetchCollectionsStartAsync();
				}
				***************************************

Conclusion:
	Redux Thunk allows us to catch the action and it's only going to detect actions that aren't objects. (It means that thunk is interested only to a function returned value, i.e. a function that returns a function instead of an object {type, payload} and thunk will give access to dispatch which will dispatch multiple actions)

	Moreover, thunk gives us the dispatch so that we can go back to giving synchronous actions action objects to the rootReducer.

----------Debugging Code-----------

Scenario:
	When this components get rendered, the fetched data is still on the process of fetching it from firestore which triggers by the fetchCollectionsStartAsync() "thunk" function which dispatch multiple actions to fetch collections object.

	By default, the value of isCollectionsFetching that is passed to the "isLoading" prop is false (as "isFetching" property is set to "false" by default before it gets change to "true" when an action gets called to update it.) 

	In the sample code below a returned component from a HOC WithSpinner returned a spinner if the isLoading is set to true, else it will return a component with the actual component (wrapped component as argument in HOC) that uses the collections object and renders it as state. 

	Sample Code:

	shop.component.jsx
	*********************************************
	componentDidMount() {
		const { fetchCollectionsStartAsync } = this.props;
		/*Call the fetchCollectionsStartAsync function the moment the component mounts*/
		fetchCollectionsStartAsync();
	}

	render() {
		const { match, isCollectionsFetching } = this.props;
		return( 
			<div className='shop-page'>

				...

				<Route 
					path={`${match.path}/:collectionId`} 
					render={(props) => 
					  	(<CollectionPageWithSpinner isLoading={!isCollectionsFetching} {...props}/>)
					}  
				/>
			</div>
		);
	};

	const mapStateToProps = createStructuredSelector({
		isCollectionsFetching: selectIsCollectionsFetching
	});
	*********************************************

	Problem:
		The collections object is not available yet which gives an error that "property of" collections object is null because the component renders in a wrong timing wherein the data is still on the way.

	Solution:
		Create a new selector which selects the collections object and return a truthy or falsy value using !! to determine if the collections object is already been fetched.

		Sample Code:

		shop.selectors.js
		************************************************
		/*Import this selector to shop.component.jsx*/

		export const selectIsCollectionsLoaded = createSelector(
			[selectCollections],

			/*Using !! to get a truthy or falsy value depending if the collections object is already been loaded*/
			collections => !!collections
		);
		************************************************
			- this allows to know if the collections is now available and set the selectors returned value as the prop value of "isLoading". And yet...

				Another Problem:
					- Still there is another problem of the "isLoading" prop value because when the collections object is null or empty string or NaN or false, the !! will return a false value which then when passed to "isLoading" property will then returned the wrappedComponent instead of the Spinner that we are trying to get. 

				Solution:
					- Put the ! before the selector's reference "isCollectionsLoaded: selectIsCollectionsLoaded" to negate the "false" value to "true" and likewise so we could render the Spinner.

					Sample Code:

					shop.component.jsx
					*******************************************
					/*FROM:*/

						<Route 
							path={`${match.path}/:collectionId`} 
							render={(props) => 
							  	(<CollectionPageWithSpinner isLoading={isCollectionsLoaded} {...props}/>)
							}  
						/>

					/*TO:*/

						<Route 
							path={`${match.path}/:collectionId`} 
							render={(props) => 
							  	(<CollectionPageWithSpinner isLoading={!isCollectionsLoaded} {...props}/>)
							}  
						/>


*********************************************

CHAPTER: 19. Master Project Container Pattern

-----------Container Pattern-------------

Scenario:
	In the ShopPage component, we are passing these two properties (isCollectionsLoaded and isCollectionsFetching) we we get the loading state of the shop reducer in order to pass them into these components that we render inside of the routes. 

	However we do nothing else with these props so it almost makes more sense for us to find a way to pass these values into the CollectionsOverviewWithSpinner and CollectionPageWithSpinner components in their own isolated environment rather than pollute our shop page component because there's nothing that the ShopPage component can do with these properties other than pass them as props to these components with spinner.

	The reason that this is redundant is because our ShopPage asks for all the components -- should be as dumb as possible. There is no reason for this component to know about things that it don't need to know about. Because the components that use these properties should be the ones in charge of determining whether or not they are being loaded or not. Or whether or not they should be rendering the spinner.

Solution:
	Leverage the higher order components except use the concept of the "Container Pattern"

	For CollectionsOverview component (example):

	1. Create a file called "collections-overview.container.jsx" under in this component directory.

	Notes:
		The container is going to be a component that gets wrapped in all of the higher order components that it needs in order to properly run the way that it expects itself to the same way how our components in ShopPage is setup.

	2. Instead of wrapping the mapStateToProps around the ShopPage in order to pass that value into our CollectionsOverviewWithSpinner, we're just gonna wrap that mapStateToProps with the value from the selectors around the CollectionsOverviewWithSpinner component instead.

	3. Do the following:

		shop-overview.container.jsx
		************************************************
		import { connect } from 'react-redux';
		import { createStructuredSelector } from 'reselect';
		import { compose } from 'redux';

		import WithSpinner from '../with-spinner/with-spinner.component';

		import CollectionsOverview from './collections-overview.component';

		import { selectIsCollectionsFetching } from '../../redux/shop/shop.selectors';

		const mapStateToProps = createStructuredSelector({

			/*"isLoading" is the property used as a prop that accepts the selectors returned value as an assigned value before implementing this container pattern*/

			isLoading: selectIsCollectionsFetching
		});

		const CollectionsOverviewContainer = connect(mapStateToProps)(WithSpinner(CollectionsOverview));

		export default CollectionsOverviewContainer;
		************************************************

		3.1. These part is hard to read so instead of doing this:
			**************************************************
			const CollectionsOverviewContainer = connect(mapStateToProps)(WithSpinner(CollectionsOverview));
			**************************************************

			*Import the "compose" component from redux. compose lets us pass these by calling a function that look like this:

			**************************************************
			const CollectionsOverviewContainer = compose(
				connect(mapStateToProps),
				WithSpinner
			)(CollectionsOverview);

			**************************************************
			Notes:
				"compose" evaluate from right to left.

				So what "compose" do is it evaluates WithSpinner first by passing in the CollectionsOverview to it and then passing WithSpinner to "connect(mapStateToProps)([...will be passed here])."

*************************************************

CHAPTER 20: Master Project Redux-Saga

------------Introduction to Sagas------------

*Simplified Flow of Redux with Sagas

Diagram:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	----------------Passed in as Props-------------------------------
	|																|
	|																V
  Store 														Components
  	^																|
  	|																|
  	|																|
 Reducers															|
 	^															Dispatch
 	|							   -----Sagas                       |
 	|							  |		  ^                         |
Pass actions on 				  |		  |                         |
	|						  Actions     |                         |
	|							  |	      |                         |
	|							  v  	  |                         V
	------------------------------ Middleware: <-----------------Actions
								Thunk, Sagas,
								 redux-logger

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	Always remember:
		Middleware catches the action before it hits the reducer.
			- it can also throw out an action so it doesn't passed to the reducer.

	Thunk vs Sagas
		Thunk
			- thunk will take an action function (not an action object with type and payload properties) and invoke it. The moment thunk invokes it and gets a dispatch inside of this action function, it will then dispatch the actual action that comes out of each dispatch call whenever it happens.

		Sagas
			- it's a function that conditionally runs and the condition that it depends on when it runs is based on whether or not a specific action is coming into the saga middleware.
			- imagine a function that is listening for the FETCH_COLLECTIONS_START action. Unless that action fires, that saga (specific saga that listens to this specifc action) does not execute.
			- the main idea with sagas is that there can be multiple sagas listening for multiple different actions or the same action but they're just pieces of code that do not run until they hear the action that they're listening for. When they do, they can do all kinds of logic -- so they can trigger other actions which go back into our middleware and continue into our reducers so other sagas can also be listening for actions that come out of sagas or they can render any kind of additional API logic. They can go to the backend and fetch some data -- use that data and dispatch actions to update reducers. The main idea with sagas is that they handled this idea fo side effects.

			Types of Side Effects:
				1. API calls to a backend
				2. Some kind of asynchronous (takes time) code or something that triggers an impure reaction.

					Pure vs Impure:
						Pure
							- a pure function when invoke will return the same value (with the same arguments).

							Example:
								function add(x,y) {
									return x + y;
								}

								/*When this function will be invoked with the same arguments many times like...*/

								add(5,7); // returns 12
								add(5,7); // returns 12
								add(5,7); // returns 12

								/*...it will return the same value*/

								/*In other words pure function are functions that accept an input and returns a value without modifying any data outside its scope(Side Effects).*/

						Impure
							- an impure function when invoke (many times), returns an unpredictable value contrary to pure function.

							Example:
								var z = 0;
								function add (x,y) {
									y = y + z;
									return x + y;
								}

								add(5,7); //returns 12
								z = 10;

								add(5,7); //returns 22

								/*
								In other words an impure function is a function that mutates variables/state/data outside of it's lexical scope, thus deeming it “impure” for this reason. */

-----------Generator Functions---------------

- building block of a saga
- is a function that resembles "async await".
	- "async await" is actually build on top of generators.
- is a function that can stop midway and then continue from where it stopped. It is a function that produces a sequence of results instead of a single value, i.e you generate ​a series of values.

Generator Function Syntax (*):

	function* gen() {
		console.log('a');
		console.log('b');
	}

	Notes:
		When this function is instantiated, meaning that when it is invoke, it actually get back this "generator object" which can cast some variable like this:

		Sample:
		******************************************
		const g = gen() 

		/*If gen() is a regular function, when it is invoke, the console.log() will be logged to the browser and "g" will be set to "undefined" because functions that don't return anything would just return "undefined".*/

		/*But when "g" is logged, it returns a suspended generator kind of object which is the "generator object"*/

		/*When g is logged*/
		g
		>>> gen {<suspended>}

		/*We call .next() to it.

		  What next() does is it will resume the execution inside of our function.


		*/
		******************************************

		Another generator function example:

		*****************************************
		function* gen(i) {
			yield i;
			yield i + 10;

			/* "yield" pauses generator function execution and the value of the expression following the yield keyword is returned to the generator's caller.*/
		}

		const g = gen(5);

		g.next() //returns 5;
		g.next() //returns 15;
		g.next() //returns an object {value: undefined, done: true} 
				  ...this means that there is no value left to be returned.


-----------redux-saga--------------

1. Install redux-saga library with the command:
|	npm install redux-saga

2. Go to the store.js and remove the thunk in the "middlewares" array.

3. Import createSagaMiddleware from redux-saga library

4. Create a new variable called sagaMiddleware using the "createSagaMiddleware()" function.

	Sample:
		const sagaMiddleware = createSagaMiddleware();

5. Add sagaMiddleware in the "middlewares" array.

Note:
	This section is creating a saga for shop-related codes.

	6. Create a new file called "shop.sagas.js" under redux/shop/ directory.

	//Importing certain effects from sagas
	/*This effects allow to do different things with either the store like creating actions or listening for actions*/

	7. Import the following:
		**********************************************
		/*What takeEvery does it it listens for every action of a specific type that we pass to it*/

		import { takeEvery } from 'redux-saga/effects';

		/*Import the ShopActionTypes because we're listening for specific action types*/

		import ShopActionTypes from './shop.types';

		**********************************************

	8. Write the first based saga. This is a function that takes the "star" syntax. What this saga does with the effect is it's going to pause whenever a specific action type that we want comes in.

		Sample Code:

		shop.saga.js
		****************************************
		import { takeEvery } from 'redux-saga/effects';

		import ShopActionTypes from './shop.types';

		/*One of the sagas*/
		export function* fetchCollectionsAsync() {
			console.log('I am fired');
		}

		/*The base saga*/
		export function* fetchCollectionsStart() {
			yield takeEvery(
				ShopActionTypes.FETCH_COLLECTIONS_START,
				fetchCollectionsAsync
			)
		}
		****************************************
		Notes:
			- takeEvery() first argument is the action that it listens for and the second argument is another generator function that will run in response to this "takeEvery" listener.

			- the whole purpose of saga middleware is its whole purpose is to run these sagas all concurrently -- meaning it wants to run all the sagas altogether in a way that does not block the execution.

			- takeEvery() creates a non-blocking call in order to not stop the application to continue running either other sagas or whatever the user wants to do. It doesn't pause the javascript waiting for anything inside of the "fetchCollectionAsync" to come back.

	9. Go to store.js and import the base saga "fetchCollectionsStart" from "shop.sagas.js".

	10. Below the "store" instance, write the following:

		Code:

		store.js
		********************************************
		import { fetchCollectionsStart } from '.shop/shop.sagas';

		... //below the store instance

		/*Runs the saga*/
		sagaMiddleware.run(fetchCollectionsStart);
		********************************************

	11. There will be an error after this because the dispatch function that will run the asynchronous action is still the "thunk" function.

	Instead of importing the fetchCollectionsStartAsync thunk function, import the fetchCollectionsStart instead which fires the action that our saga is listening for (FETCH_COLLECTIONS_START) and declare it inside the componentDidMount() as a replacement for the "thunk" function. This will solve the error.

	...break

------------Redux Thunk into Saga------------

Code From Redux-Thunk:

	shop.actions.js
	******************************************************
	/*The "thunk" function*/

	export const fetchCollectionsStartAsync = () => {
		return dispatch => {
			/*Creating the collections reference*/
			const collectionsRef = firestore.collection('collections');

			/*Dispatching the function that will update the reducer's state "isFetching" to true...*/
			dispatch(fetchCollectionsStart());

			/*...Beginning of asynchronous request*/
			collectionsRef
				.get()
				.then(snapshot => {
					const collectionsMap = convertCollectionsSnapshotToMap(snapshot);
					/*Dispatching the function that will update the reducer with payload*/
					dispatch(fetchCollectionsSuccess(collectionsMap));
				})
				.catch(error => dispatch(fetchCollectionsFailure(error.message))
				);
		}
	}
	******************************************************
	 Notes:
	 	The thunk function is the one that held the logic of dispatching the subsequent follow up actions of updating our reducers or informing us that we had an error. 

	 	Now instead of doing it in an action, we now do it in a saga which is why we switched our page action that we fire inside our shop page back to the original fetchCollectionsStart() (...instead of the "thunk" function) action

	 	We no longer need an asynchronous action like the "thunk" function to handle that logic.
	 	
...continuation

12. Import the firestore and convertCollectionsSnapshotToMap utility in "firebase.utils.js" in shop.sagas.js.

13.	Import the action creators: fetchCollectionsSuccess() and fetchCollectionsFailure from  "shop.actions.js".	

14. In the "shop.sagas.js", under the saga function that respond with the takeEvery effect base saga as the second argument, write the following code:
	
	Code:

	shop.sagas.js
	**********************************************
	export function* fetchCollectionsAsync() {

	/*Getting the collections reference*/
	const collectionsRef = firestore.collection('collections');

	/*...Beginning of asynchronous request*/
	try {
		const snapshot = yield collectionsRef.get();

		/*call() is the effect inside of our generator function that invokes the method.
		  -yielding this call of this method incase this call takes longer than we expect.
		  - what call does is it accepts the function to be called as the first argument and passes the functions parameters through its second argument
		*/
		const collectionsMap = yield call(convertCollectionsSnapshotToMap, snapshot);
		

		/*put() is the dispatch() equivalent of dispatching action object to the reducer in redux-saga the only difference is we have to yield it.*/
		yield put(fetchCollectionsSuccess(collectionsMap));

	} catch (error) {
		yield put(fetchCollectionsFailure(error.message));
	}

	/* This is the "thunk" equivalent way of doing the above saga:
		collectionsRef
			.get()
			.then(snapshot => {
				const collectionsMap = convertCollectionsSnapshotToMap(snapshot);
				Dispatching the function that will update the reducer with payload
				dispatch(fetchCollectionsSuccess(collectionsMap));
			})
			.catch(error => dispatch(fetchCollectionsFailure(error.message))
			);
	*/
	}
	**********************************************
	Notes:
		- Use try and catch block to handle errors just like in async await.
		- logger knows what type of action is being created and these are saga actions.

Data Flow of the App with Redux Saga of the example above:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

		-------------------------------------------------------------------------------------------------------------
		|																											|
		|																											|
Shop Reducer: {																										|
	collections: [...] 																								|
		^																											|
		|						fetchCollectionStartAsync															|			|					...code to get some stuff to firestore ----------                                       |
		|									^								|										|
		|									|								|										|
		|									|					---------------------------							|
Pass actions to reducers  					|							Dispatch new 	                    		|
		|									|						    FETCH_COLLECTIONS_SUCCESS or	    		|
		|					    fetchCollectionStart:                   FETCH_COLLECTIONS_FAILURE action    		|
		|					{type: FETCH_COLLECTIONS_START}      --------------------------          				|
		|									^								|										|
		|									|								|										|
		|									|								|										|
		-----------------------------Saga Middleware <----------------------------Dispatch action: ---------- Component							  												      {type: FETCH_COLLECTIONS_START}
	

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Notes:
	When the Shop Page component did mount, it will dispatch the action to the reducer and will pass to the saga middleware first if this action is one of the actions that the middleware listens for.

	If so, then when the base saga function generator (action listener) hears of this specific action (FETCH_COLLECTIONS_START for instance), it will invoke a function generator that will handle the asynchronous request of getting the collections from firestore.

	If it is successful, then it will dispatch an action (FETCH_COLLECTIONS_SUCCESS for instance) to the reducer to update the "collections" state with the new "collections" from the database.

	If it fails, then it will dispatch the action (FETCH_COLLECTIONS_FAILURE) to the reducer to update the error state.


-----------take(), takeEvery(), takeLatest() Effects--------

1. take
	- it waits for an action that it listening for -- for it to happen. When it does, we're able to actually get the payload from this action as well if we wanted to.
	- it gives back as a promise that gives resolved the actual payload value of this action if we had one.

	Sample Code:
	************************************
	export function* incrementSaga() {
		const incrementPayload = yield take('INCREMENT');


	}
	************************************
	Notes:
		When an action triggers, the take effect runs ones but not runs from top to bottom again when the same action triggers which the take effect listen for because "take" is following the basic the generator function.

2. takeEvery
	- unlike "take" effect, it fires a new task using the generator that is passed to it as its second argument. 

	Sample Code:
	************************************
	import { takeEvery } from 'redux-saga/effects';

	export function* onIncrement() {
		yield console.log('I am incremented');
	}

	export function* incrementSaga() {
		yield takeEvery(
			'INCREMENT',
			onIncrement
		);
	}
	************************************
	Notes:
		When we trigger the action that takeEvery is listening for, under the hood, redux-saga is firing off a new task to run the onIncrement saga code.

		Everytime the action object is fired, redux-saga is actually regenerating that generator (onIncrement). It's calling this onIncrement generator again and again. It's not running through the same incrementSaga() instead it's looping and listening for every increment call and then creaating new iterations or new tasks that are equivalent to whatever generator function that we pass to it.
			- this is the big benefit of using "takeEvery" because we are able to actually loop and reuse this increment code more than one time and listen to all actions that come from the actions that takeEvery is listening for in a non-blocking way unlike "take" effect.

3. takeLatest
	- no matter how many times an action gets trigger (by a button, etc.), "takeLatest" effect will cancel all the previous task(saga) and only trigger the latest one that was clicked.
	- pass the action payload to the new task (as an argument) that will be invoked in response to this effect.

	Sample Code:
	************************************
	import { takeLatest, delay } from 'redux-saga/effects';

	export function* onIncrement() {
		yield console.log('I am incremented');
		yield delay(3000); //in milliseconds
		yield put({ type: 'INCREMENT_FROM_SAGA'})
	}

	export function* incrementSaga() {
		yield takeLatest(
			'INCREMENT',
			onIncrement
		);
	}
	************************************
	Notes:
		takeLatest effect still spawning a new saga every time the user clicks on the button but because the delay is 3000 ms meaning that our onIncrement() saga is stuck for 3000 ms we only ended up resolving one increment from saga because whenever it hits the delay and those latest clicks were coming in, redux saga was actually cancelling every previous spawn saga that was generated except for the latest one.

-----------Root Saga-------------

Scenario:
	When we want to add another saga to run, we need to call the instance of createSagaMiddleware which is the "sagaMiddleware" and chain .run() which is redundant.

Solution:
	We want to create a root saga which handles all the base sagas to run all at once.

	Steps:
		1. Create a file called "root-saga.js" under redux directory.

		2. Inside of this file import "all" and "call" effects.

		3. Import the sagas that we want to call all at once from "shop.sagas.js".

		4. Define your root saga generator function which will be exported to the store.js

			Sample Code:

			root.saga.js
			************************************************
			import { all, call } from 'redux-saga/effects';

			import { fetchCollectionsStart } from './shop/shop.sagas';

			export default function* rootSaga() {
				yield all([
					call(fetchCollectionsStart),
					call(anotherSaga),
					...and so on
				]);
			}
			************************************************
			Notes:
				- What "all" effect does is it accepts a list of sagas inside the "call" effect as argument so that all base sagas (listeners) will be call at once.

		5. Export this generator function to the "store.js" and pass it as an argument of sagaMiddleware.run([saga]).

			Sample Code:

			store.js
			********************************************
			import rootSaga from './root-saga';

			...

			sagaMiddleware.run(rootSaga);
			********************************************
			Notes:
				So instead of doing like...

				*************************************************
				sagaMiddleware.run(baseSaga1);
				sagaMiddleware.run(baseSaga2);
				sagaMiddleware.run(baseSaga3);
				...and so on to run all our saga action listeners
				*************************************************

				...we just use the new created "rootSaga" which run all these sagas at once.

------------Google Sign In into Sagas-----------

Scenario:
	Refactoring the GoogleSignIn from Observable Pattern to Promised based way of signing in the user. 

Problem:
	We want to use redux-saga to handle the signing of user with GoogleSignIn using redux-saga instead of observable pattern as an instance wherein if the company you are working with uses promised based of handling this signing in form.

Comparison:
	*The Observable Pattern sample code:

		App.js
		*********************************************************
		unsubscribeFromAuth = null;

		componentDidMount() {
			const { setCurrentUser } = this.props;
			this.unsubscribeFromAuth = auth.onAuthStateChanged(async userAuth => {
				if(userAuth) {
					const userRef = await createUserProfileDocument(userAuth);

					userRef.onSnapshot(snapShot => {
						setCurrentUser({
							currentUser: {
								id: snapShot.id,
								...snapShot.data()
							}
						});
					});
				}
				else {
					setCurrentUser(userAuth);
				}
			});
		}

		componentWillUnmount() {
			this.unsubscribeFromAuth();
		}
		*********************************************************

	*The Promised Pattern with redux-saga sample code:

		user.sagas.js
		*********************************************************
		function* signInWithGoogle() {
			try {
				const { user } = yield auth.signInWithPopup(googleProvider);
				const userRef = yield call(createUserProfileDocument, user);
				const userSnapshot = yield userRef.get();
				yield put(googleSignInSuccess({ id: userSnapshot.id, ...userSnapshot.data() }));
			} catch (error) {
				yield put(googleSignInFailure(error));
			}
		}

		export function* onGoogleSignInStart() {
			yield takeLatest(UserActionTypes.GOOGLE_SIGN_IN_START, signInWithGoogle);
		}

		export function* userSagas() {
			yield all([
				call(onGoogleSignInStart)
			]);
		}
		*********************************************************
		Notes:
			When the user clicks on the signin button, an action (object) will be dispatched to the reducer, wherein before it hits to the reducer, Redux Saga middleware (onGoogleSignInStart function generator) listens to this event which in response if this event has been fired, it will invoke the saga (signInWithGoogle) that handles the signing in with google and the storing of the user data to the firebase's firestore, and the setting of the current user in the App to show the SignOut button on the Home Page.
Solution:
	Steps:
		1. Create an action object that will be passed to the reducer (which also is the action that the based saga is listening for).

			1.1. Also add the action that is needed when the fetching of data is successful so this action will be fired to update the reducer's state with the new user payload.

			1.2. Also add the action that will handle the error when the request fails.

			(see user.actions.js in this project for reference)

		2. Create a file called "user.sagas.js" (since this scenario focuses to the user state).

		3. In user.sagas.js, define the base saga which listens for the action to be fired.

			3.1. Import the "takeLatest" effect because we want to get the last action when the user clicks on the button (because the user has the possibility to click the button more than once)

		4. Define the saga which will handle the signing in with google which is the function generator that will be invoked by the "takeLatest" effect as a response when it hears the action that it listening for.

			4.1. Import the following from "firebase.utils.js" 
				- auth, 
					(to use the ".signInWithPopup([...the provider])")

				- googleProvider, 
					(the provider that will be passed as an argument to the ".signInWithPopup()")

				- createUserProfileDocument
					(which is a function defined to store the user data to the firestore and returned the user reference as a returned value which will be used to get the user snapshot)

			4.2. Import also the action creator (the action when data is successfully fetched, and the action when data fetching fails).

		5. Handle the request with the try-and-catch block to handle request error

		6. Inside the try block do something like this:
			Example Code:
			*************************************************************
			try {
				/* waiting of the sign in process to be done, and destructure the user property from the returned value (which is the object with the user object that is signed in) */

				const { user } = yield auth.signInWithPopup(googleProvider);

				//calling the function that will store the users info to the firestore
				const userRef = yield call(createUserProfileDocument, user);

				//using the user reference and chaining .get() to get the user snapshot
				const userSnapshot = yield userRef.get();

				//dispatching the action object to the reducer with the new user payload when it succeed
				yield put(googleSignInSuccess({ id: userSnapshot.id, ...userSnapshot.data() }));

			} catch (error) {
				/*ispatching the action that will change the "error" state (in the reducer) with the error value handled by catch block*/

				yield put(googleSignInFailure(error));
			}


			//Defining the root saga for user sagas. This saga will be passed to the rootSaga (which will be passed also as an argument of the sagaMiddleware.run() which run all the base sagas through it)

			//first import the "all" and "call" effects from 'redux-saga/effects';

			export function* userSagas() {
				yield all([
					call(onGoogleSignInStart)
				]);
			}
			*************************************************************

			...

			Overview of the rootSaga function generator:

			root-saga.js
			*************************************************************
			import { all, call } from 'redux-saga/effects';

			import { userSagas } from './user/user.sagas';

			export default function* rootSaga() {
				yield all([
					call(userSagas)
				]);
			}
			*************************************************************

			...

			In the store.js
			*************************************************************
			(... some libraries)

			import createSagaMiddleware from 'redux-saga';
			import rootSaga from './root-saga';

			const sagaMiddleware = createSagaMiddleware();

			const middlewares = [sagaMiddleware];

			(... some other codes (if there were))

			/*runs all the sagas to listen to all the specific action that each of the base saga is listening for*/

			sagaMiddleware.run(rootSaga);
			*************************************************************
Remember:
	The same installation setup is done when applying redux-thunk library in the app.


------------ Email Sign In into Sagas---------------

* It's almost the same with "Google Sign In into Sagas".

* Just remember to create a new function / function generator if a part of the code is written twice just to follow the DRY principle.

	Example Code:

	user.sagas.js
	****************************************************
	//DO THIS:
	//reused function used by sagas to implement DRY (DO NOT REPEAT YOURSELF) principle.
	function* getSnapshotFromUserAuth(userAuth) {
		try {
			const userRef = yield call(createUserProfileDocument, userAuth);
			const userSnapshot = yield userRef.get();
			yield put(signInSuccess({ id: userSnapshot.id, ...userSnapshot.data() }));
		} catch (error) {
			yield put(signInFailure(error));
		}
	}

	function* signInWithGoogle() {
		try {
			const { user } = yield auth.signInWithPopup(googleProvider);
			yield getSnapshotFromUserAuth(user);
		} catch (error) {
			yield put(signInFailure(error));
		}
	}

	function* signInWithEmail({ payload: { email, password }}) {
		try {
			const { user } = yield auth.signInWithEmailAndPassword(email, password);
			yield getSnapshotFromUserAuth(user);
		} catch (error) {
			yield put(signInFailure(error));
		}
	}



	//NOT THIS:
	function* signInWithGoogle() {
		try {
			const { user } = yield auth.signInWithPopup(googleProvider);

			//This is redundant
			const userRef = yield call(createUserProfileDocument, userAuth);
			const userSnapshot = yield userRef.get();
			yield put(googleSignInSuccess({ id: userSnapshot.id, ...userSnapshot.data() }));
		} catch (error) {
			yield put(googleSignInFailure(error));
		}
	}

	function* signInWithEmail({ payload: { email, password }}) {
		try {
			const { user } = yield auth.signInWithEmailAndPassword(email, password);

			//This is redundant
			const userRef = yield call(createUserProfileDocument, userAuth);
			const userSnapshot = yield userRef.get();
			yield put(emailSignInSuccess({ id: userSnapshot.id, ...userSnapshot.data() }));
		} catch (error) {
			yield put(emailSignInFailure(error));
		}
	}
	****************************************************
	Notes:
		- Change the action types to make this code simple and non-repetitive if you want to add another action (object).
		- Remember to change the action types in the "action creator" and "reducer action" (UNIDIRECTIONAL DATA FLOW) when a new action types has been added or updated.

-------------Recreating Persistence-------------

Scenario:
	When a user signed in and redirected to the homepage with the button changed from "SignIn" to "Signout", when it accidentally closes the tab and get back to the app, the user is not signed in even if the user haven't signed out yet.

	When we changed the way we signin user from Observable pattern using the observer called .onAuthStateChange() - which listens for the current user that is signed in and pass that user onto the userAuth parameter which then set this user as the current user in the redux "currentUser" state (which was used by the header component to render the SignOut button rather than the SignIn button) to Promised pattern, we remove this observer in our code.

Solution:
	1. Create a new action (object) in "user.actions.js" that will be dispatched (when the component mounts) which is the action that will be a cue for our action listener (some base saga function generator) to check the user session from firebase.

	Sample Code:

	user.actions.js
	***************************************************
	export const checkUserSession = () => ({
		type: UserActionTypes.CHECK_USER_SESSION
	});
	***************************************************

	2. Define a based saga that will listen to the action cue.
	
	Sample Code:

	user.sagas.js
	***************************************************
	export function* onCheckUserSession() {
		yield takeLatest(UserActionTypes.CHECK_USER_SESSION, [...new task w/c is "isUserAuthenticated" for instance]);
	}
	***************************************************

	3. Define the saga that will be invoked in response to "takeLatest" effect when it hears the action that it listening for.
		3.1. Create a utility function in "firebase.utils.js" and do the following:

			Sample Code:

			firebase.utils.js
			***************************************************
			//A utility function that returns the current user object as a promise that was signed in on firestore.

			export const getCurrentUser = () => {
				return new Promise((resolve, reject) => {
					const unsubscribe = auth.onAuthStateChanged(userAuth => {
						unsubscribe();
						resolve(userAuth);
					}, reject);
				});
			}
			***************************************************

		3.2. Check if the returned value of the utility function is not null, if it is not then declare the function that will handle the returned value to get the user snapshot from it and pass the snapshot as an argument for the action (object) that will be dispatched and update the user reducer with the new user payload. As a result, when the header component renders, it renders the SignOut button instead because the current user exists.



		Sample Code (for step 3):

		user.sagas.js
		***************************************************
		function* isUserAuthenticated() {
			const userAuth = yield getCurrentUser();

			//checks if userAuth is null, ... it returns nothing if it is.
			if(!userAuth) return;

			yield getSnapshotFromUserAuth(userAuth);
		}
		***************************************************

Remember:
	Do not forget to call the newly created base saga to activate this listener in the whole application.


------------Sign Out with Sagas------------

Scenario:
	When signing out, we declare an anonymous function that will invoke the "auth.signOut()" function which is also an API that request to signout from firebase. 

	When the use clicks the button, the page doesn't signout.

Solution:
	1. Create new actions with their action types that is in the following:

		SIGN_OUT_START
			//which is an action cue to the saga listener to start the sign out request process from firebase.
		SIGN_OUT_SUCCESS
			//which is an action that will be dispatched when the sign out request succeed and will update the reducers current user state to 'null'.
		SIGN_OUT_FAILURE
			//which is an action that will be dispatched when an api request rejection takes place which accepts an error argument from the catch block and update the reducer with the new error payload.


	2. Add new cases to the reducer:

		Example Code:

		user.reducer.js
		***************************************************

		... some other codes...

		case UserActionTypes.SIGN_OUT_SUCCESS:
			return {
				...state,
				currentUser: null
			}
		case UserActionTypes.SIGN_OUT_FAILURE:
			return {
				...state,
				error: action.payload
			}
		***************************************************

	3. Dispatch the action cue (SIGN_OUT_START) in the header.component and pass it as a value in the synthetic event "onClick" which when the user clicks on the button, this action will be dispatched and heard by the saga listener to start the sign out process.

	4. Create the base saga that will listen to the action cue.

		Example Code:

		user.sagas.js
		**************************************************
		export function* onSignOutStart() {
			yield takeLatest(UserActionTypes.SIGN_OUT_START, signOut)
		}
		**************************************************

	5. Create the saga that will execute the signing out process (which is the new task that will be invoke as a response to an effect)

		Example Code:

		user.sagas.js
		**************************************************
		function* signOut() {
			try{
				yield auth.signOut();
				yield put(signOutSuccess());
			} catch (error) {
				yield put(signOutFailure(error));
			}
		}
		**************************************************

	6. Call the base saga so it will run as one of the middleware that listens for a specific action.

-----------Sign Up with Sagas----------

1. Do the same process as signin but remember when the signup process succeed, make sure you have created a new saga listener for the action that got dispatched (SIGN_UP_SUCCESS) and make use of the payload from the action (this payload is a raw user object - not yet transform into another format) to call the function that the signin saga uses to signin user. In other words, the user signs up, afterwards, the user will be signed in automatically in the background. (This purpose is to implement DRY principle. Hence, the main uses of components)


*****************************************************************************************************

CHAPTER 21. Master Project React Hooks

----------useState-------------

- let you use state and other React features without writing a class.

Syntax:
	const [property, setProperty] = useState([property initial value]);

	Example Code:
		******************************************
		const [user, setUser] = useState(null);
		******************************************

		Note:
			This will define a user state with an initial value of null.

			This property can be updated using the defined setUser setter by doing like this:
				****************************************
				setUser('Jaztin');
				****************************************

---------useEffect----------

- it gives the ability to fire side effects inside of our functional components.

- it does not get back any value unlike useState.

- it gets a function that gets called whenever the component changes or whenever the component updates and re-renders.

	Example:
	****************************************
	useEffect(() => {
		console.log('Hello');
	});
	****************************************
	Notes:
		-When component mounts for the first time, this effect will fire because this is mimicking the componentDidMount() lifecycle method.

		-it will also fire whenever the component rerenders.

		-remember that when state change in any ways, the component always rerenders just like a class component.

		- useEffect is not just mimicking componentDidMount but also mimicking any update lifecycle methods that fire whenever render gets called.

			- in order to just mimic only the componentDidMount, put a second parameter on the useEffect hook.

			- the second parameter will be an array. This array takes properties that this effect has access to that will not trigger a rerender.

			- only pass an empty array if you want to apply this effect once the component mounts.

- if you want to use an async function (like for fetching purposes), encapsulate the async function with another function (usually anonymous).	

	Example Code:
	***************************************
	useEffect(() => {
		async () => {

		}
	});
	***************************************		
	Notes:
		async function returns an async function object which is not what useEffect accepts as an argument because it accepts a function.

Building a componentDidMount like function using useEffect:

	Sample Code:
	***************************************		
	useEffect(() => {
		const fetchFunc = async () => {
			const response = await fetch(`some address`);
			const resJson = await response.json();
			setUser(resJson[0])
		};

		//Call the fetchFunc which will fetch from the json and give as a response and convert in to json.

		fetchFunc();
	});
	***************************************	
	Notes:
		- Remember to put an empty/valued array as a second argument of useEffect. 

		- Be careful of passing a property in this array because it may cause an infinite loop inside of the component

----------Hook Rules----------

Scenario:
	If we didn't want the useEffect hook to fire because the search query did not exist yet or at the very least it was not anything meaningful we think that we can actually use the "if block" statement to make a condition of something before the useEffect will be updated by applying the useEffect inside the inside the statement which is incorrect.

Solution:
	Inside the useEffect, use the "if block" statement and encapsulate all the code that should be running when the condition was met.

	Example Code:
	*********************************************
	useEffect(() => {
		/*
			This will fetch something if the someStateProperty that the fetch is dependent on is not empty or null.
		*/

		if([someStateProperty].length > 0) {
			const fetchFunc = async () => {
				const response = await fetch(`some address`);
				const resJson = await response.json();
				setUser(resJson[0])
			};
		}

		fetchFunc();
	});
	********************************************* 


----------useEffect as ComponentWillUnmount()-----------

useEffect is a function that can also return a function called a "cleanup function".

Clean-Up Function
	- is what useEffect calls when the component unmounts.

	Example Code:
	*******************************************
	useEffect(() => {

		//Cleanup function
		return () => {
			unsubscribeFromAuth();
		}
	});
	*******************************************
	Question:
		Why whould we want something like this?
	Answer:
		When you want to unsubscribe after you subscribed to an observable stream of events (Observable Pattern) like in firebase.

----------Custom Hooks-----------

* Creating custom hooks is somewhat the same as creating HOC.

* When you create custom hooks, under "src" folder, create a new folder called "effects" and in this folder create a file for your custom hook in a naming convention format like "use-someVerb.effect.js".

	Example:

		Scenario:
			When two components uses fetch to fetch data from a fake api with useEffect() hook. In order to reuse the code, we want to create a custom hook.

		Solution:
			1. Create a new file called "use-fetch.effect.js" under "effects" folder.

			2. Sample Code:

			***************************************
			import { useState, useEffect } from 'react';

			const useFetch = url => {
				const [data, setData] = useState(null);

				useEffect(() => {
					const fetchData = async () => {
						const res = await fetch(url);
						const dataArray = res.json();
						setData(dataArray[0]);
					};

					fetchData();
				});

				return data;
			};
			export default useFetch;
			***************************************
			Notes:
				We didn't pass a second argument for the useEffect hook because we always want to get the live data from the API in case the data has been changed.

				But if we want to call useEffect everytime the url changes, then we pass that "url" inside an array to conditionally fire useEffect() hook.

			3. Import this hook to the components and just call useFetch and pass the fake API url as the argument for this hook. Make sure you define a container variable which will hold the returned value from this hook. 

-----------useReducer-----------

- let us actually build out reducer functions and leverage them a state management inside of our components the same way that useState() hook does except it's going to follow a similar flow of data of firing actions and then those actions changing a reducer object of some kind the way we've seen with redux except localized to a component.

- this hook is really great in places where you need more complex local state management.

Using useReducer Hook:
	1. Import useReducer from react library.

		Syntax:
		*******************************************
			const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
		*******************************************
		Notes:
			- Remember that most hooks that return a value is in Array data type.

			- We get two things from the useReducer hook. They are:
				1. state
					- the current state of the reducer.

				2. dispatch
					- being the literal function that we get that allows us to pass actions to our reducer.

			- In order to instantiate this reducer, we pass two things:
				1. reducer
					- the reducer itself. The reducer being the function that gets both the "state" and an "action" and then using a switch statement returns back some object that represents our state. This is the same as the reducer in redux.

				2. INITIAL_STATE
					- the initial/defaul state value.

	2. Initialize you INITIAL_STATE object outside the component scope (before component definition. Also same with reducer and action).

	3. Define your reducer function.

	4. Define your action function that return action object.

	5. Dispatch your action to update the reducer with the new payload using the "dispatch".

	~ All of this implementation is exactly the same with the redux.

- useReducer hook is a native react way of implementing redux.

- sometimes it's actually very useful to use this when you need something a little bit more miniscule (small) than a full redux implementation inside of your application but you think you need something more complex than simply just using useState() hook.


*************************************************

CHAPTER #22. Master Project Stripe Payments Part 2 - Backend


-----------Introduction to Backend-----------

* Stripe needs a backend.

* Stripe has two keys:
	1. Publishable key
		- this is the key needed in the front-end to use the stripe checkout component which allows us to input our payment credentials.

	2. Secret Key
		- this is the secret key needed to be stored hidden from the users. This is the key used to allow successful actual payment using Stripe services and should be stored in the backend server.

		Note:
			- Other users are not able to intercept that key when we're making payments through the frontend application.

			- If people were to get access to the secret key, they would be able to technically make payments on our behalf or take things out with this secret key.

			- They can also steal or intercept people's stripe payments when they're in the middle of being sent to our backend.

			- There is nothing you can truly hide on the frontend. You absolutely must keep anything related that you want to hide on the backend.

* The backend server takes requests and sends it out (response).


Node
	- is an environment that let us run javascript outside of the browser.

	- Node.js code is in the Backend Server to handle logic.


Rest Backend Diagram:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


							 -------  ------------send homepage html/css/js---------------------
		------------------->| /home | <-----------GET homepage data-------------------------   |
		|					 -------													   |   |
		|																				   |   |
		|																				   |   V
 ---------------------			 -------										       -----------------
| Rest Backend Server | ------->| /shop | <----------GET shop page data-------------- | Web Application |
 ---------------------			 -------  -----------send shop page html/css/js----->  -----------------
		|																				   |   ^
		|																				   |   |
		|					 -----------												   |   |
		------------------->| /checkout | <-----GET checkout data---------------------------   |
							 -----------  ------send checkout html/css/js-----------------------


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Description:
	- The Web application send a request to GET/DELETE/UPDATE some data through an endpoint (route e.g. /home) in the server and the REST Backend Server send a response with what was requested.

	- In React, the backend server will send a response in JSON format instead of some html/css/js.
	  - React uses JS to manipulate the DOM so we don't need to get some html/css/js from the server (which will cost much time to load a page)


------------ Creating the Server inside the Project--------

Setup:
	1. Under the project folder (crwn-clothing), create a new folder called "client".
		Note:
			Use the CLI for this.

	2. Move all the files in the project folder to the client folder using the command:

		|	mv ./* ./client

	3. Under the project folder, create a new "package.json" because the server has its own dependencies.

	4. Create a new file called "server.js" for our server.
		Note:
			This server.js file will represent pretty much the entry point for our server code.

	5. Modify the package.json with:

		*********************************************
		{
		  "name": "crwn-clothing-server",
		  "version": "1.0.0",
		  "scripts": {
		    "client": "cd client && npm start", 
		    		//change directory to client and start the application.
		    "server": "nodemon server.js",      
		    		//wrap the server.js with nodemon which will allow live-reloading when changes was made in the server codes.
		    "build": "cd client && npm run build", 
		    		//change directory to client and run a build/optimized version of the application.
		    "dev": "concurrently --kill-others-on-fail \"npm run server\" \"npm run client\"", 
		    		//run both the server and the client
		    "start": "node server.js", 
		    		//this script is included for heroku.
		    "heroku-postbuild": "cd client && npm install && npm install --only=dev --no-shrinkwrap && npm run build"
		    		//this script will run heroku itself after it's finished building
		  },
		  "dependencies": {
		    "body-parser": "^1.18.3",
		    		//convert requests bodies into JSON
		    "compression": "1.7.4",
		    "cors": "2.8.5",
		    		//handle cross-origin-requests.
		    "dotenv": "7.0.0",
		    		//allows to actually store secret keys.
		    "express": "^4.16.4",
		    "stripe": "6.28.0"
		    		//library use to make charges (payment)
		  },
		  "devDependencies": {
		    "concurrently": "^4.0.1"
		  }
		}
		***********************************************
		Notes:
			- "concurrently" package will allow us run both of the server and the client in one terminal.

				- it also allows us to pass this kill others on fail which means that if one breaks, the other one will also break.

				- this is the main benefit of running "concurrently".

			- heroku can't use nodemon to wrap and run the server.

				- hot reloading is only needed for development purposes.


			- "heroku-postbuild" will go to the client and it's going to install all of the node modules and then it's going to install any of our dev dependencies.

				- the no-shrinkwrap is a flag that we were put in where we don't want to shrink wrappings.

				- Shrink wrappings just means that it locks down all of the dependency versions which we just don't want that to do

	6. Install nodemon with the command:
		|	npm install -g nodemon
		
	7. With the terminal, run the command to install all the dependencies for the server.
		|	npm install


----------Building a Basic Server----------

1. Import express using the ES5 way of importing using the "require" keyword.
	
	Note:
		In node.js, it uses the ES5 instead of ES6. In other words, we don't have access to the "import" keyword when we want to leverage a library.

2. Import cors.

3. Import the body-parser library

4. Import path. 
	- path gets bundled into any node project so we don't actually bring in to our package.json.

	- what this module does is it let us build out pathing for our directories. 

		- the reason for this is in file production builds, most builds get optimized and you don't actually know a lot of the times what the directory name.

		- path just allows it in the moment to calculate it for us.

		- the main idea of path is that it allows us to dynamically build when we call it from our current directory to where we're actually trying to go.

	Sample Code:

	server.js
	********************************************
	const express = require('express');
	const cors = require('cors');
	const bodyParser = require('body-parser');
	const path = require('path');
	********************************************

5. Create a new file called ".env". Set the secret key value from your stripe account.

	Sample Code:

	.env
	********************************************
	STRIPE_SECRET_KEY = [YOUR_STRIPE_SECRET_KEY]
	********************************************

6. In server.js, require "dotenv" library only in development node environment.

	Sample Code:

	server.js
	********************************************
	...imported libraries

	if(process.env.NODE_ENV !== 'production') {
		require('dotenv').config();
	}
	********************************************
	Note:
		- This loads the "dotenv" into the process environment (process.env) which allows the process.env now to access that secret key. 

7. Inside the .gitignore file, add the .env file. 

	Sample Code:

	.gitignore
	*******************************************
	.DS_Store
	...some things

	.env
	*******************************************


	Note:
		In this way, we make sure that we don't ever send any sensitive information we put in the .env and into any repos because that pretty much eliminates the purpose of trying to make it secret.

8. Use express library by instantiating it.

	Sample Code:

	server.js
	******************************************
	...

	const app = express();
	******************************************
	Note:
		- This will instantiate for us a new express application.

9. Set the port that we're going to use.

	Sample Code:

	server.js
	******************************************
	...

	const port = process.env.PORT || 5000;
	******************************************
	Note:
		- This will set the port automatically for us when we host it using heroku, else, it will set the port to 5000.

10. In package.json (client project folder), add a proxy key which create-react-app will know how to use.

	Sample Code:

	client/package.js
	*****************************************
	{
	  "name": "crwn-clothing",
	  "version": "0.1.0",
	  "private": true,
	  "proxy": "http://localhost:5000",

	  ...
	}
	*****************************************

11. Apply the necessary middlewares using the .use() method from express instance.

	Sample Code:

	server.js
	*****************************************
	...

	//Middlewares

	/*Convert body to json()*/
	app.use(bodyParser.json());

	/*
		Makes sure that the uri do not contain spaces or symbols
	*/

	app.use(bodyParser.urlencoded({ extended: true }));

	/*
		CORS stands for "Cross-Origin-Requests"
		Allows cross origin requests from different origins (e.g. PORT 3000 request to PORT 5000)
	*/

	app.use(cors());
	*****************************************

12. Serve the client application now that we're hosting our own web server.

	Example Code:

	server.js
	*****************************************
	...

	if(process.env.NODE_ENV === 'production') {
		app.use(express.static(path.join(__dirname, 'client/build')));

		/*
			Sending static file(s) for every url the user hits (endpoint).

			For any route that is not covered by the future routes we're going to write, it will hit to this endpoint and send the static file(s).
		*/

		app.get('*', function(req, res) {
			res.sendFile(path.join(__dirname, 'client/build', 'index.html'));
		});
	}
	*****************************************
	Notes:
		- Whenever heroku receives a request, it's going to determine based on the url path what to do. Because now we are dynamically in control of telling this server what we want to host it, what we want to send back to the client that's asking for something.

		-express.static() allows us to serve a certain file inside of this url that we pass to it or this "path".

		- the path that we passed was using our "path" library and we're joining this directory (__dirname) which tells us what directory we're currently in and then we're pointing to "client/build".

		- the only way that we're actually able to serve it is we have to say what route we want to use it.

13. Listen

	Example Code:

	server.js
	****************************************
	app.listen(port, error => {
		if(error) throw error;
		console.log('Serving running on port', port);
	});
	****************************************

----------What we are building---------

1. Set up the first route that allows to make the stripe charge.

	Note:
		In order for the charge to be legitimate, it needs to actually come with a secret key that we get from stripe that we need to send with our request to stripe in order to make the charge so that stripe knows that the charge is coming from our account.


Payment Flow Diagram:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	  Clientside App
			|
			|
			|
			|
    Send payment token
   			|
			|
			|
			V
		/payment  ------------ Make Payment -----> Stripe
			|				Charge to Stripe
	  Express Server

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Explanation:
	Clientside App will send a payment token to the payment route (/payment).

	The payment route is then going to take that token and then use the stripe library to actually make a payment charge to stripe.


-----------Backend Payment Route-----------

1. In server.js, define the payment route. 

	Example Code:

	server.js
	**************************************
	app.post('/payment', (req, res) => {
	/*	
		Create the proper body object that we pass the stripe using values that we get from the token and that token of course as we know is going to come in through the requests that we make from our fontend.
	*/
		const body = {
			source: req.body.token.id,
			amount: req.body.amount,
			currency: 'usd'
		};
	}
	**************************************

2. Pass the body object to stripe so do the following:

	2.1. After the line where dotenv library is required, write the following:

		Example Code:

		server.js
		**************************************
		... 

		/*
			Requiring stripe library and directly invoking the function from stripe that will accept the secret key as an argument which will then return a stripe object which allows to make charges.
		*/

		const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

		**************************************
		Note:
			In order to actually leverage the stripe library that we're trying to bring in, we need access to that secret key that was stored in the .env file.

3. After the defined body object, create a new stripe charges.

	Example Code:

	server.js
	****************************************
	...

	post('/payment', (...) => {

		... body object

		//Creating new Stripe charges
		stripe.charges.create(body, (stripeErr, stripeRes) => {
			if(stripeErr) {
				res.status(500).send({ error: stripeErr });
			} else {
				res.status(200).send({ success: stripeRes});
			}
		});
	});
	****************************************
	Note:
		create() first argument is for the "body" object.
		The second argument is a callback function which accepts the error object as the first arg if an stripe api request fails, and the res object as the second arg when it succeed.


-------------Connecting Client to Server----------

1. Using the terminal, on the project root directory, run the command:

	|	npm run dev

	Note:
		This will start both the backend server and the client application.

2. Go to the stripe-button component from the frontend, inside the function that gets called when the payment form is passed (onToken function). Post the token with the amount to the server through the payment route using native fetch() or axios library by doing the following:

	Example Code:

	stripe-button.component.jsx
	**************************************************
	const onToken = token => {

		/* Using native fetch()
		*******************************************/

		fetch('http://localhost:5000/payment', {
			method: 'post',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				amount: priceForStripe,
				token
			})
		})
			.then(response => {
				alert('Payment successful!');
			})
			.catch(error => {
				alert('Payment error: ', JSON.parse(error));
			}); 

		/* Using axios
		*******************************************/

		axios({
			method: 'post',
			url: 'payment',
			data: {
				amount: priceForStripe,
				token
			}
		})
		.then((...) => {
			...
		})
		.catch(error) => {
			...
		});
	};
	**************************************************

	Note:
		To install axios, use the command:
			|	npm install axios


----------Deploying to Production-----------

* To check the list of project hosted on Heroku, use the following command:

	|	heroku apps

Scenario:
	- Before creating the backend server, we deploy our create-react application to heroku where we use "buildpack" to optimized our code for us before it was hosted to heroku.

	- Now, when we create the server, the server itself will build/optimized the client application for us instead of buildpack. 

Solution:
	- Remove the buildpack that is used by doing the following:

		1. Checking what buildpack is used:
			|	heroku buildpacks

		2. Removing buildpack
			|	heroko buildpacks:remove [...paste the buildpack url here]

			Example:
				|	heroku buildpacks:remove mars/create-react-app

Committing changes to heroku:

1. git add -A
2. git commit -m "...message here"
3. Set the heroku configuration to enable to access the stripe secret key from .env file by using the command:
	|	heroku config:set STRIPE_SECRET_KEY=[your_secret_key]	

	Note:
		If you forgot to set the new configuration to heroku, the stripe charges will fail. You will get a request error with status 400 on the console.









	